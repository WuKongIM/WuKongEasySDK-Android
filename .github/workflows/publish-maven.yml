# WuKongIM Android EasySDK - Modern Portal API Publishing Workflow
# Streamlined workflow using only Central Publisher Portal API
# Generates all required artifacts with checksums and signatures

name: ğŸ“¦ Publish to Maven Central via Portal API

on:
  # Trigger on version tags (e.g., v1.0.0, v1.2.3, v2.0.0-beta.1)
  push:
    tags:
      - 'v*'
  
  # Allow manual triggering for testing and emergency releases
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to publish (e.g., 1.0.0)'
        required: true
        type: string
      dry_run:
        description: 'Perform a dry run (build without publishing)'
        required: false
        type: boolean
        default: false

# Ensure only one publishing workflow runs at a time
concurrency:
  group: publish-maven-portal
  cancel-in-progress: false

jobs:
  publish:
    name: ğŸš€ Build and Publish to Maven Central
    runs-on: ubuntu-latest
    if: github.event.inputs.dry_run != 'true'
    
    environment: 
      name: maven-central
      url: https://search.maven.org/artifact/com.githubim/easysdk-android
    
    steps:
      # Step 1: Checkout the repository
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for proper version detection
      
      # Step 2: Extract version from tag or input
      - name: ğŸ·ï¸ Extract Version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
            echo "Using manual version: $VERSION"
          else
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "Using tag version: $VERSION"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Publishing version: $VERSION"
      
      # Step 3: Set up Java JDK 17
      - name: â˜• Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
      
      # Step 4: Cache Gradle dependencies
      - name: ğŸ“¦ Cache Gradle Dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-
      
      # Step 5: Make Gradle wrapper executable
      - name: ğŸ”§ Make Gradle Wrapper Executable
        run: chmod +x gradlew
      
      # Step 6: Validate Gradle wrapper
      - name: âœ… Validate Gradle Wrapper
        uses: gradle/actions/wrapper-validation@v3
      
      # Step 7: Configure GPG signing
      - name: ğŸ” Configure GPG Signing
        run: |
          echo "Setting up GPG signing..."

          # Create .gnupg directory if it doesn't exist
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg

          # Verify all required secrets are present
          if [ -z "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "Error: GPG_PRIVATE_KEY secret is not set"
            exit 1
          fi

          if [ -z "${{ secrets.SIGNING_KEY_ID }}" ]; then
            echo "Error: SIGNING_KEY_ID secret is not set"
            exit 1
          fi

          if [ -z "${{ secrets.SIGNING_PASSWORD }}" ]; then
            echo "Error: SIGNING_PASSWORD secret is not set"
            exit 1
          fi

          echo "All GPG secrets are present"

          # Decode base64 GPG private key
          echo "Decoding GPG private key..."
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | base64 --decode > $HOME/private.key

          # Verify the key file was created and has content
          if [ ! -s "$HOME/private.key" ]; then
            echo "Error: GPG private key file is empty after decoding"
            exit 1
          fi


          echo "GPG private key decoded successfully"

          # Import the GPG key with verbose output
          echo "Importing GPG private key..."
          if gpg --batch --yes --import $HOME/private.key; then
            echo "âœ… GPG key imported successfully"
          else
            echo "âŒ Failed to import GPG key"
            exit 1
          fi
          
          # List imported keys to verify
          echo "Imported GPG keys:"
          gpg --list-secret-keys --keyid-format LONG

          # Verify the specific key ID exists
          echo "Verifying key ID ${{ secrets.SIGNING_KEY_ID }}..."
          if gpg --list-secret-keys --keyid-format LONG | grep -q "${{ secrets.SIGNING_KEY_ID }}"; then
            echo "âœ… Key ID ${{ secrets.SIGNING_KEY_ID }} found in keyring"
          else
            echo "âŒ Key ID ${{ secrets.SIGNING_KEY_ID }} not found in keyring"
            echo "Available key IDs:"
            gpg --list-secret-keys --keyid-format LONG | grep "sec" || echo "No secret keys found"
            exit 1
          fi

          # Set GPG configuration for non-interactive signing
          echo "Configuring GPG for non-interactive signing..."
          cat > ~/.gnupg/gpg.conf << EOF
          use-agent
          pinentry-mode loopback
          batch
          no-tty
          trust-model always
          EOF

          # Configure GPG agent
          cat > ~/.gnupg/gpg-agent.conf << EOF
          allow-loopback-pinentry
          default-cache-ttl 86400
          max-cache-ttl 86400
          pinentry-program /usr/bin/pinentry-curses
          EOF

          # Set proper permissions
          chmod 600 ~/.gnupg/gpg.conf
          chmod 600 ~/.gnupg/gpg-agent.conf

          # Restart GPG agent
          echo "Restarting GPG agent..."
          gpgconf --kill gpg-agent || true
          sleep 2
          gpgconf --launch gpg-agent

          # Verify GPG agent is running
          if gpgconf --list-components | grep -q "gpg-agent"; then
            echo "âœ… GPG agent is running"
          else
            echo "âš ï¸ GPG agent status unclear"
          fi
          
          # Test GPG signing capability with comprehensive validation
          echo "Testing GPG signing capability..."
          echo "test content for GPG signing validation" > test-sign.txt

          # Test signing with explicit parameters
          echo "Attempting to sign test file..."
          if gpg --batch --yes --pinentry-mode loopback \
            --passphrase "${{ secrets.SIGNING_PASSWORD }}" \
            --armor --detach-sign \
            --default-key "${{ secrets.SIGNING_KEY_ID }}" \
            --output test-sign.txt.asc \
            test-sign.txt; then
            echo "âœ… GPG signing test successful"

            # Verify the signature file was created and has content
            if [ -s "test-sign.txt.asc" ]; then
              echo "âœ… Signature file created with content"

              # Check signature file format
              if head -1 test-sign.txt.asc | grep -q "BEGIN PGP SIGNATURE"; then
                echo "âœ… Signature file has correct PGP format"

                # Display signature file for debugging
                echo "ğŸ“‹ Signature file content:"
                cat test-sign.txt.asc

                # Verify the signature
                echo "Verifying signature..."
                if gpg --verify test-sign.txt.asc test-sign.txt 2>&1; then
                  echo "âœ… GPG signature verification successful"
                else
                  echo "âŒ GPG signature verification failed"
                  echo "This may indicate a problem with the signing process"
                  exit 1
                fi
              else
                echo "âŒ Signature file doesn't have correct PGP format"
                echo "Signature file content:"
                cat test-sign.txt.asc
                exit 1
              fi
            else
              echo "âŒ Signature file was not created or is empty"
              exit 1
            fi
          else
            echo "âŒ GPG signing test failed"
            echo "Possible causes:"
            echo "  - Incorrect SIGNING_KEY_ID"
            echo "  - Incorrect SIGNING_PASSWORD"
            echo "  - GPG key not properly imported"
            echo "  - GPG agent configuration issues"
            exit 1
          fi

          # Test signing with different parameters to ensure compatibility
          echo "Testing alternative signing method..."
          echo "alternative test content" > test-sign2.txt

          if gpg --batch --yes --pinentry-mode loopback \
            --passphrase "${{ secrets.SIGNING_PASSWORD }}" \
            --armor --detach-sign \
            --local-user "${{ secrets.SIGNING_KEY_ID }}" \
            test-sign2.txt; then
            echo "âœ… Alternative signing method also works"
          else
            echo "âš ï¸ Alternative signing method failed (may not be critical)"
          fi

          # Cleanup test files
          rm -f test-sign.txt test-sign.txt.asc test-sign2.txt test-sign2.txt.asc

          echo "GPG signing configured and tested successfully"
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}
          SIGNING_KEY_ID: ${{ secrets.SIGNING_KEY_ID }}

      # # Step 7.5: Run comprehensive GPG diagnostics
      # - name: ğŸ” Run GPG Diagnostics
      #   run: |
      #     echo "Running comprehensive GPG diagnostics..."
      #     chmod +x scripts/diagnose-gpg-signing.sh
      #     ./scripts/diagnose-gpg-signing.sh
      #   env:
      #     GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
      #     SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}
      #     SIGNING_KEY_ID: ${{ secrets.SIGNING_KEY_ID }}

      # Step 8: Build, Sign, and Generate Checksums
      - name: ğŸ” Build and Sign All Artifacts
        run: |
          echo "Building and signing all artifacts with checksums..."
          echo "Version: $VERSION"

          # Run Gradle signing diagnostics first
          echo "ğŸ” Running Gradle signing diagnostics..."
          ./gradlew diagnoseSigning --no-daemon

          # Build and sign all artifacts including sources and javadoc
          ./gradlew clean build \
            androidSourcesJar \
            androidJavadocJar \
            publishToMavenLocal \
            --no-daemon \
            --stacktrace \
            --info \
            -Pversion=$VERSION

          echo "âœ… All artifacts built and signed successfully"

          # Verify GPG signatures were created during build
          echo "ğŸ” Verifying GPG signatures were created during build..."
          MAVEN_LOCAL_DIR="$HOME/.m2/repository/com/githubim/easysdk-android/$VERSION"

          if [ -d "$MAVEN_LOCAL_DIR" ]; then
            SIGNATURE_FILES=$(find "$MAVEN_LOCAL_DIR" -name "*.asc" | wc -l)
            echo "Found $SIGNATURE_FILES signature files in Maven local repository"

            if [ "$SIGNATURE_FILES" -gt 0 ]; then
              echo "ğŸ“‹ Signature files found:"
              find "$MAVEN_LOCAL_DIR" -name "*.asc" -exec basename {} \;

              # Verify each signature file
              echo "ğŸ” Verifying signature file contents..."
              for asc_file in "$MAVEN_LOCAL_DIR"/*.asc; do
                if [ -f "$asc_file" ]; then
                  filename=$(basename "$asc_file")
                  echo "Checking $filename..."

                  if [ -s "$asc_file" ]; then
                    if head -1 "$asc_file" | grep -q "BEGIN PGP SIGNATURE"; then
                      echo "  âœ… $filename has correct PGP format"

                      # Verify the signature against its corresponding file
                      base_file="${asc_file%.asc}"
                      if [ -f "$base_file" ]; then
                        if gpg --verify "$asc_file" "$base_file" 2>/dev/null; then
                          echo "  âœ… $filename signature verification passed"
                        else
                          echo "  âŒ $filename signature verification failed"
                          echo "  ğŸ“‹ Signature content:"
                          head -5 "$asc_file"
                        fi
                      else
                        echo "  âš ï¸ Corresponding file for $filename not found"
                      fi
                    else
                      echo "  âŒ $filename doesn't have correct PGP format"
                      echo "  ğŸ“‹ File content:"
                      head -3 "$asc_file"
                    fi
                  else
                    echo "  âŒ $filename is empty"
                  fi
                fi
              done
            else
              echo "âŒ No signature files found - signing may have failed"
              echo "ğŸ” Available files in Maven local directory:"
              ls -la "$MAVEN_LOCAL_DIR"
            fi
          else
            echo "âŒ Maven local directory not found: $MAVEN_LOCAL_DIR"
          fi

          # Generate checksums for all artifacts
          MAVEN_LOCAL_DIR="$HOME/.m2/repository/com/githubim/easysdk-android/$VERSION"
          echo "Generating checksums in: $MAVEN_LOCAL_DIR"

          if [ -d "$MAVEN_LOCAL_DIR" ]; then
            cd "$MAVEN_LOCAL_DIR"

            # Generate MD5 and SHA1 checksums for all artifacts
            for file in *.aar *.pom *.jar; do
              if [ -f "$file" ]; then
                echo "Generating checksums for: $file"

                # Generate MD5 checksum
                md5sum "$file" | cut -d' ' -f1 > "${file}.md5"
                echo "âœ… Generated MD5: ${file}.md5"

                # Generate SHA1 checksum
                sha1sum "$file" | cut -d' ' -f1 > "${file}.sha1"
                echo "âœ… Generated SHA1: ${file}.sha1"
              fi
            done

            cd - > /dev/null

            echo "ğŸ“¦ Final artifacts with checksums and signatures:"
            ls -la "$MAVEN_LOCAL_DIR"

            # Verify we have all required files
            ARTIFACT_COUNT=$(find "$MAVEN_LOCAL_DIR" -name "*.aar" -o -name "*.pom" -o -name "*.jar" | grep -v "\.asc$" | wc -l)
            SIGNATURE_COUNT=$(find "$MAVEN_LOCAL_DIR" -name "*.asc" | wc -l)
            CHECKSUM_COUNT=$(find "$MAVEN_LOCAL_DIR" -name "*.md5" -o -name "*.sha1" | wc -l)

            echo "ğŸ“Š Artifact summary:"
            echo "   - Artifacts: $ARTIFACT_COUNT"
            echo "   - Signatures: $SIGNATURE_COUNT"
            echo "   - Checksums: $CHECKSUM_COUNT"

            if [ "$SIGNATURE_COUNT" -gt 0 ] && [ "$CHECKSUM_COUNT" -gt 0 ]; then
              echo "âœ… All artifacts have signatures and checksums"
              echo "artifacts_ready=true" >> $GITHUB_ENV
            else
              echo "âŒ Missing signatures or checksums"
              echo "artifacts_ready=false" >> $GITHUB_ENV
            fi
          else
            echo "âŒ Maven local repository directory not found"
            echo "artifacts_ready=false" >> $GITHUB_ENV
          fi
        env:
          OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
          OSSRH_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}
          SIGNING_KEY_ID: ${{ secrets.SIGNING_KEY_ID }}
          SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}

      # Step 8.5: Validate Portal API Compatible Signatures
      - name: ğŸ” Validate Portal API Signatures
        run: |
          echo "Validating signatures for Portal API compatibility..."
          chmod +x scripts/validate-portal-signatures.sh
          ./scripts/validate-portal-signatures.sh $VERSION
        env:
          SIGNING_KEY_ID: ${{ secrets.SIGNING_KEY_ID }}
          SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}

      # Step 9: Create Portal API Bundle
      - name: ğŸ“¦ Create Portal API Bundle
        if: env.artifacts_ready == 'true'
        run: |
          echo "Creating Portal API deployment bundle..."

          # Use Maven local repository as source (contains signed artifacts and checksums)
          MAVEN_LOCAL_DIR="$HOME/.m2/repository/com/githubim/easysdk-android/$VERSION"

          # Run bundle creation script with Maven local repository
          ./scripts/create-portal-bundle.sh $VERSION "$MAVEN_LOCAL_DIR"

          # Verify bundle was created
          if [ -f "central-bundle.zip" ]; then
            BUNDLE_SIZE=$(du -h central-bundle.zip | cut -f1)
            echo "âœ… Bundle created successfully: central-bundle.zip ($BUNDLE_SIZE)"

            # Verify bundle contents include signatures and checksums
            echo "ğŸ“‹ Bundle contents:"
            unzip -l central-bundle.zip

            SIGNATURE_COUNT=$(unzip -l central-bundle.zip | grep -c "\.asc$" || true)
            CHECKSUM_COUNT=$(unzip -l central-bundle.zip | grep -c -E "\.(md5|sha1)$" || true)

            # Ensure counts are valid integers
            SIGNATURE_COUNT=${SIGNATURE_COUNT:-0}
            CHECKSUM_COUNT=${CHECKSUM_COUNT:-0}

            echo "ğŸ“Š Bundle verification:"
            echo "   - Signature files: $SIGNATURE_COUNT"
            echo "   - Checksum files: $CHECKSUM_COUNT"

            if [ "$SIGNATURE_COUNT" -gt 0 ] && [ "$CHECKSUM_COUNT" -gt 0 ]; then
              echo "âœ… Bundle contains all required files"
              echo "bundle_created=true" >> $GITHUB_ENV
            else
              echo "âš ï¸ Bundle missing required files"
              echo "bundle_created=false" >> $GITHUB_ENV
            fi
          else
            echo "âŒ Failed to create bundle"
            echo "bundle_created=false" >> $GITHUB_ENV
          fi

      # Step 10: Upload to Portal API
      - name: ğŸš€ Upload to Portal API
        if: env.bundle_created == 'true'
        run: |
          echo "Uploading to Portal API..."

          # Create base64 encoded credentials
          CREDENTIALS=$(echo -n "${{ secrets.OSSRH_USERNAME }}:${{ secrets.OSSRH_PASSWORD }}" | base64)

          # Upload bundle to Portal API
          echo "Uploading bundle to Portal API..."

          # Capture both response and HTTP code
          UPLOAD_RESPONSE=$(curl -X POST \
            -H "Authorization: Bearer $CREDENTIALS" \
            -F "bundle=@central-bundle.zip" \
            -F "name=WuKongIM Android EasySDK v$VERSION" \
            "https://central.sonatype.com/api/v1/publisher/upload?publishingType=USER_MANAGED" \
            --silent --show-error --max-time 300 -w "%{http_code}")

          HTTP_CODE="${UPLOAD_RESPONSE: -3}"
          RESPONSE_BODY="${UPLOAD_RESPONSE%???}"

          echo "Portal API HTTP Code: $HTTP_CODE"
          echo "Portal API Response: $RESPONSE_BODY"

          if [ "$HTTP_CODE" = "201" ] && [ -n "$RESPONSE_BODY" ] && [ "$RESPONSE_BODY" != "null" ]; then
            DEPLOYMENT_ID="$RESPONSE_BODY"
            echo "âœ… Portal API upload successful"
            echo "Deployment ID: $DEPLOYMENT_ID"
            echo "portal_deployment_id=$DEPLOYMENT_ID" >> $GITHUB_ENV
            echo "portal_upload_success=true" >> $GITHUB_ENV

            # Monitor deployment status
            echo "Monitoring deployment status..."
            for i in {1..10}; do
              STATUS=$(curl -X POST \
                -H "Authorization: Bearer $CREDENTIALS" \
                "https://central.sonatype.com/api/v1/publisher/status?id=$DEPLOYMENT_ID" \
                --silent | jq -r '.deploymentState' 2>/dev/null || echo "UNKNOWN")

              echo "Status check $i: $STATUS"

              case $STATUS in
                "VALIDATED")
                  echo "âœ… Deployment validated and ready for manual release"
                  echo "ğŸ”— View at: https://central.sonatype.com/publishing/deployments"
                  break
                  ;;
                "PUBLISHED")
                  echo "ğŸ‰ Deployment automatically published to Maven Central"
                  break
                  ;;
                "FAILED")
                  echo "âŒ Deployment failed validation"
                  curl -X POST \
                    -H "Authorization: Bearer $CREDENTIALS" \
                    "https://central.sonatype.com/api/v1/publisher/status?id=$DEPLOYMENT_ID" \
                    --silent | jq '.errors' 2>/dev/null || echo "No error details available"
                  echo "portal_upload_success=false" >> $GITHUB_ENV
                  exit 1
                  ;;
                "PENDING"|"VALIDATING"|"PUBLISHING")
                  echo "â³ Deployment in progress: $STATUS"
                  if [ $i -eq 10 ]; then
                    echo "â° Monitoring timeout - check Portal manually"
                    echo "ğŸ”— View at: https://central.sonatype.com/publishing/deployments"
                  else
                    sleep 30
                  fi
                  ;;
                *)
                  echo "â“ Unknown status: $STATUS"
                  sleep 30
                  ;;
              esac
            done
          else
            echo "âŒ Portal API upload failed"
            echo "HTTP Code: $HTTP_CODE"
            echo "Response: $RESPONSE_BODY"

            # Check for specific error types
            if echo "$RESPONSE_BODY" | grep -q "Invalid signature"; then
              echo "ğŸ” Signature validation error detected"
              echo "ğŸ“‹ This indicates GPG signing issues in the bundle"
            elif [ "$HTTP_CODE" = "401" ]; then
              echo "ğŸ” Authentication error - check Portal credentials"
            elif [ "$HTTP_CODE" = "400" ]; then
              echo "ğŸ“¦ Bundle format error - check bundle contents"
            fi

            echo "portal_upload_success=false" >> $GITHUB_ENV
            exit 1
          fi
        env:
          OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
          OSSRH_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}

      # Step 11: Final Status Report
      - name: ğŸ“Š Final Publishing Status Report
        if: always()
        run: |
          echo ""
          echo "ğŸ¯ PUBLISHING STATUS REPORT"
          echo "================================"
          echo ""
          echo "ğŸ“¦ Version: $VERSION"
          echo "ğŸ“‹ Artifacts: $( [ "${{ env.artifacts_ready }}" = "true" ] && echo "âœ… Ready" || echo "âŒ Not Ready" )"
          echo "ğŸ“¦ Bundle: $( [ "${{ env.bundle_created }}" = "true" ] && echo "âœ… Created" || echo "âŒ Failed" )"
          echo "ğŸš€ Upload: $( [ "${{ env.portal_upload_success }}" = "true" ] && echo "âœ… Successful" || echo "âŒ Failed" )"

          if [ -n "${{ env.portal_deployment_id }}" ]; then
            echo "ğŸ†” Deployment ID: ${{ env.portal_deployment_id }}"
          fi

          echo ""
          echo "ğŸ“‹ NEXT STEPS:"

          if [ "${{ env.portal_upload_success }}" = "true" ]; then
            echo "âœ… Portal API Upload Successful:"
            echo "   1. ğŸ”— Visit: https://central.sonatype.com/publishing/deployments"
            echo "   2. ğŸ” Find deployment: WuKongIM Android EasySDK v$VERSION"
            echo "   3. âœ… Review validation results"
            echo "   4. ğŸš€ Manually release to Maven Central (if validated)"
            echo "   5. ğŸ“Š Monitor release progress"
          else
            echo "âŒ Portal API Upload Failed:"
            echo "   1. ğŸ” Review workflow logs for errors"
            echo "   2. ğŸ” Verify authentication credentials"
            echo "   3. ğŸ“¦ Check bundle contents and signatures"
            echo "   4. ğŸ”§ Fix issues and retry"
          fi

          echo ""
          echo "ğŸ”— USEFUL LINKS:"
          echo "   â€¢ Central Publisher Portal: https://central.sonatype.com/publishing/deployments"
          echo "   â€¢ Maven Central Search: https://search.maven.org/artifact/com.githubim/easysdk-android"
          echo "   â€¢ Documentation: https://central.sonatype.org/publish/"
          echo "   â€¢ Support: central-support@sonatype.com"

          echo ""
          echo "ğŸ‰ Publishing workflow completed!"

      # Step 12: Clean up sensitive files
      - name: ğŸ§¹ Clean Up Sensitive Files
        if: always()
        run: |
          echo "Cleaning up sensitive files..."
          rm -f $HOME/private.key
          rm -f central-bundle.zip
          rm -f central-bundle.zip.metadata
          # Clean up GPG agent
          gpgconf --kill gpg-agent || true
          echo "Cleanup completed"
