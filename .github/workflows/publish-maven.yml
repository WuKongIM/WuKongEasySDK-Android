# WuKongIM Android EasySDK - Maven Central Publishing Workflow
# This workflow automates the publishing process to Maven Central repository
# Triggers on version tags (v*) and manual dispatch for testing

name: ðŸ“¦ Publish to Maven Central

on:
  # Trigger on version tags (e.g., v1.0.0, v1.2.3, v2.0.0-beta.1)
  push:
    tags:
      - 'v*'
  
  # Allow manual triggering for testing and emergency releases
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to publish (e.g., 1.0.0)'
        required: true
        type: string
      dry_run:
        description: 'Perform a dry run (build without publishing)'
        required: false
        type: boolean
        default: false

# Ensure only one publishing workflow runs at a time
concurrency:
  group: publish-maven
  cancel-in-progress: false

jobs:
  # Job 1: Build, Test, and Validate
  build-and-test:
    name: ðŸ”¨ Build and Test
    runs-on: ubuntu-latest
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      is-prerelease: ${{ steps.version.outputs.is-prerelease }}
      
    steps:
      # Step 1: Checkout the repository
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for proper version detection
      
      # Step 2: Extract version from tag or input
      - name: ðŸ·ï¸ Extract Version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
            echo "Using manual version: $VERSION"
          else
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "Using tag version: $VERSION"
          fi
          
          # Check if this is a prerelease (contains alpha, beta, rc, or SNAPSHOT)
          if [[ "$VERSION" =~ (alpha|beta|rc|SNAPSHOT) ]]; then
            IS_PRERELEASE=true
            echo "Detected prerelease version"
          else
            IS_PRERELEASE=false
            echo "Detected stable release version"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "is-prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_ENV
      
      # Step 3: Set up Java JDK 17
      - name: â˜• Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
      
      # Step 4: Cache Gradle dependencies for faster builds
      - name: ðŸ“¦ Cache Gradle Dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-
      
      # Step 5: Make Gradle wrapper executable
      - name: ðŸ”§ Make Gradle Wrapper Executable
        run: chmod +x gradlew
      
      # Step 6: Validate Gradle wrapper
      - name: âœ… Validate Gradle Wrapper
        uses: gradle/actions/wrapper-validation@v3
      
      # Step 7: Run unit tests
      - name: ðŸ§ª Run Unit Tests
        run: |
          echo "Running unit tests..."
          ./gradlew test --no-daemon --stacktrace
          echo "Unit tests completed successfully"
      
      # Step 8: Run lint checks
      - name: ðŸ” Run Lint Checks
        run: |
          echo "Running lint analysis..."
          ./gradlew lint --no-daemon
          echo "Lint checks completed"
      
      # Step 9: Build the library and generate artifacts
      - name: ðŸ—ï¸ Build Library and Artifacts
        run: |
          echo "Building Android library..."
          ./gradlew clean build --no-daemon --stacktrace
          echo "Build completed successfully"
      
      # Step 10: Generate test coverage report (optional - requires JaCoCo plugin)
      - name: ðŸ“Š Generate Coverage Report
        run: |
          echo "Skipping coverage report - JaCoCo plugin not configured"
          echo "To enable coverage reports, add JaCoCo plugin to build.gradle"
      
      # Step 11: Upload test results
      - name: ðŸ“‹ Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            build/reports/tests/
            build/reports/lint-results*.html

      # Step 12: Upload build artifacts
      - name: ðŸ“¦ Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            build/outputs/aar/
            build/libs/
          retention-days: 30

  # Job 2: Publish to Maven Central
  publish-maven:
    name: ðŸš€ Publish to Maven Central
    runs-on: ubuntu-latest
    needs: build-and-test
    if: success() && (github.event.inputs.dry_run != 'true')
    
    environment: 
      name: maven-central
      url: https://search.maven.org/artifact/com.githubim/easysdk-android
    
    steps:
      # Step 1: Checkout repository
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      # Step 2: Set up Java JDK 17
      - name: â˜• Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
      
      # Step 3: Restore Gradle cache
      - name: ðŸ“¦ Restore Gradle Cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-
      
      # Step 4: Set version environment variable
      - name: ðŸ·ï¸ Set Version
        run: |
          VERSION="${{ needs.build-and-test.outputs.version }}"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Publishing version: $VERSION"
      
      # Step 5: Configure GPG signing
      - name: ðŸ” Configure GPG Signing
        run: |
          echo "Setting up GPG signing..."

          # Create .gnupg directory if it doesn't exist
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg

          # Create GPG key file from secret with proper error handling
          if [ -z "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "Error: GPG_PRIVATE_KEY secret is not set"
            exit 1
          fi

          # Decode base64 GPG private key
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | base64 --decode > $HOME/private.key

          # Verify the key file was created and has content
          if [ ! -s "$HOME/private.key" ]; then
            echo "Error: GPG private key file is empty after decoding"
            exit 1
          fi

          # Import the GPG key with verbose output for debugging
          echo "Importing GPG private key..."
          gpg --batch --yes --import $HOME/private.key

          # List imported keys to verify
          echo "Imported GPG keys:"
          gpg --list-secret-keys --keyid-format LONG

          # Set GPG configuration for non-interactive signing
          echo "use-agent" > ~/.gnupg/gpg.conf
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          echo "batch" >> ~/.gnupg/gpg.conf
          echo "no-tty" >> ~/.gnupg/gpg.conf

          # Configure GPG agent
          echo "allow-loopback-pinentry" > ~/.gnupg/gpg-agent.conf
          echo "default-cache-ttl 86400" >> ~/.gnupg/gpg-agent.conf
          echo "max-cache-ttl 86400" >> ~/.gnupg/gpg-agent.conf

          # Set proper permissions
          chmod 600 ~/.gnupg/gpg.conf
          chmod 600 ~/.gnupg/gpg-agent.conf

          # Restart GPG agent
          gpgconf --kill gpg-agent || true
          gpgconf --launch gpg-agent

          # Test GPG signing capability
          echo "test" | gpg --batch --yes --pinentry-mode loopback --passphrase "${{ secrets.SIGNING_PASSWORD }}" --armor --detach-sign --default-key "${{ secrets.SIGNING_KEY_ID }}"

          echo "GPG signing configured and tested successfully"
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}
          SIGNING_KEY_ID: ${{ secrets.SIGNING_KEY_ID }}
      
      # Step 6: Create gradle.properties with signing configuration
      - name: ðŸ“ Configure Gradle Properties
        run: |
          echo "Creating gradle.properties with signing configuration..."

          cat > gradle.properties << EOF
          # Signing configuration
          signing.keyId=${{ secrets.SIGNING_KEY_ID }}
          signing.password=${{ secrets.SIGNING_PASSWORD }}

          # OSSRH credentials
          ossrhUsername=${{ secrets.OSSRH_USERNAME }}
          ossrhPassword=${{ secrets.OSSRH_PASSWORD }}

          # Android configuration
          android.useAndroidX=true
          kotlin.code.style=official
          android.nonTransitiveRClass=true

          # Gradle configuration
          org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
          org.gradle.parallel=true
          org.gradle.caching=true

          # GPG configuration for signing
          signing.gnupg.executable=gpg
          signing.gnupg.useLegacyGpg=false
          signing.gnupg.keyName=${{ secrets.SIGNING_KEY_ID }}
          signing.gnupg.passphrase=${{ secrets.SIGNING_PASSWORD }}
          EOF

          echo "Gradle properties configured"
      
      # Step 7: Publish to Maven Central Staging
      - name: ðŸ“¤ Publish to Maven Central Staging
        run: |
          echo "Publishing to Maven Central staging repository..."
          echo "Version: $VERSION"

          # Publish to staging repository
          ./gradlew publishReleasePublicationToOSSRHRepository \
            --no-daemon \
            --stacktrace \
            --info \
            -Pversion=$VERSION

          echo "Successfully published to staging repository"
        env:
          OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
          OSSRH_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}
          SIGNING_KEY_ID: ${{ secrets.SIGNING_KEY_ID }}
          SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}

      # Step 7.5: Trigger deployment visibility in Central Publisher Portal
      - name: ðŸ”„ Trigger Portal Deployment
        continue-on-error: true  # Don't fail the workflow if this step fails
        run: |
          echo "Triggering deployment visibility in Central Publisher Portal..."

          # Wait for the deployment to be processed by the staging API
          echo "Waiting for deployment to be processed..."
          sleep 30

          # Create base64 encoded credentials for API authentication
          CREDENTIALS=$(echo -n "${{ secrets.OSSRH_USERNAME }}:${{ secrets.OSSRH_PASSWORD }}" | base64)

          echo "Searching for staging repositories first..."

          # First, search for any existing staging repositories
          SEARCH_HTTP_CODE=$(curl -w "%{http_code}" -o search_response.txt -X GET \
            "https://ossrh-staging-api.central.sonatype.com/manual/search/repositories?profile_id=com.githubim&ip=any" \
            -H "Authorization: Bearer $CREDENTIALS" \
            -H "Accept: application/json")

          echo "Search HTTP response code: $SEARCH_HTTP_CODE"

          if [ "$SEARCH_HTTP_CODE" -eq 200 ]; then
            echo "Search response:"
            cat search_response.txt

            # Check if we have any repositories
            if grep -q '"repositories"' search_response.txt && grep -q '"key"' search_response.txt; then
              echo "Found staging repositories, analyzing repository states..."

              # Parse repositories and find suitable candidates for portal deployment
              echo "Repository analysis:"
              grep -o '"key":"[^"]*","state":"[^"]*","description":[^,]*,"portal_deployment_id":[^}]*' search_response.txt | while IFS= read -r repo_info; do
                REPO_KEY=$(echo "$repo_info" | grep -o '"key":"[^"]*"' | sed 's/"key":"\([^"]*\)"/\1/')
                REPO_STATE=$(echo "$repo_info" | grep -o '"state":"[^"]*"' | sed 's/"state":"\([^"]*\)"/\1/')
                PORTAL_ID=$(echo "$repo_info" | grep -o '"portal_deployment_id":[^,}]*' | sed 's/"portal_deployment_id":\([^,}]*\)/\1/')

                echo "  Repository: $REPO_KEY"
                echo "  State: $REPO_STATE"
                echo "  Portal ID: $PORTAL_ID"
                echo ""
              done

              # Find the best repository for portal deployment
              # Priority: open state without portal_deployment_id
              BEST_REPO_KEY=""
              BEST_REPO_STATE=""

              # Look for open repositories without portal_deployment_id first
              while IFS= read -r repo_info; do
                REPO_KEY=$(echo "$repo_info" | grep -o '"key":"[^"]*"' | sed 's/"key":"\([^"]*\)"/\1/')
                REPO_STATE=$(echo "$repo_info" | grep -o '"state":"[^"]*"' | sed 's/"state":"\([^"]*\)"/\1/')
                PORTAL_ID=$(echo "$repo_info" | grep -o '"portal_deployment_id":[^,}]*' | sed 's/"portal_deployment_id":\([^,}]*\)/\1/')

                if [ "$REPO_STATE" = "open" ] && [ "$PORTAL_ID" = "null" ]; then
                  BEST_REPO_KEY="$REPO_KEY"
                  BEST_REPO_STATE="$REPO_STATE"
                  echo "âœ… Found suitable repository for portal deployment: $REPO_KEY (state: $REPO_STATE)"
                  break
                fi
              done < <(grep -o '"key":"[^"]*","state":"[^"]*","description":[^,]*,"portal_deployment_id":[^}]*' search_response.txt)

              if [ -n "$BEST_REPO_KEY" ]; then
                echo "Attempting portal deployment with repository: $BEST_REPO_KEY"

                # Try to trigger portal deployment using the selected repository
                UPLOAD_HTTP_CODE=$(curl -w "%{http_code}" -o upload_response.txt -X POST \
                  "https://ossrh-staging-api.central.sonatype.com/manual/upload/repository/$BEST_REPO_KEY?publishing_type=user_managed" \
                  -H "Authorization: Bearer $CREDENTIALS" \
                  -H "Accept: application/json")

                echo "Upload HTTP response code: $UPLOAD_HTTP_CODE"
                echo "Upload response:"
                cat upload_response.txt

                case $UPLOAD_HTTP_CODE in
                  200|201|202)
                    echo "âœ… Successfully triggered portal deployment"
                    ;;
                  400)
                    ERROR_MSG=$(cat upload_response.txt)
                    if echo "$ERROR_MSG" | grep -q "No objects found"; then
                      echo "âš ï¸ Repository exists but no artifacts found yet"
                      echo "â„¹ï¸ This is normal - artifacts may still be uploading"
                      echo "â„¹ï¸ The deployment should appear in Portal once upload completes"
                    elif echo "$ERROR_MSG" | grep -q "No repository found"; then
                      echo "âš ï¸ Repository not accessible or already processed"
                      echo "â„¹ï¸ Check Central Publisher Portal for deployment status"
                    else
                      echo "âš ï¸ Portal deployment returned 400: $ERROR_MSG"
                    fi
                    ;;
                  *)
                    echo "âš ï¸ Portal deployment trigger returned HTTP $UPLOAD_HTTP_CODE"
                    echo "â„¹ï¸ This may be normal - check Central Publisher Portal"
                    ;;
                esac
              else
                echo "â„¹ï¸ No suitable repositories found for portal deployment"
                echo "â„¹ï¸ Reasons could be:"
                echo "   - All repositories are already closed or processed"
                echo "   - All repositories already have portal_deployment_id"
                echo "   - Deployment is being processed automatically"
                echo ""
                echo "â„¹ï¸ This is often normal for Maven-like deployments"
                echo "â„¹ï¸ Check Central Publisher Portal: https://central.sonatype.com/publishing/deployments"
              fi
            else
              echo "â„¹ï¸ No staging repositories found yet"
              echo "This is normal for Maven-like deployments - they may not create explicit staging repositories"
              echo "The deployment should still be visible in the Central Publisher Portal"
            fi
          else
            echo "âš ï¸ Could not search for repositories (HTTP $SEARCH_HTTP_CODE)"
            echo "This may indicate authentication issues or the namespace is not yet available"
          fi

          echo "Portal deployment step completed (non-blocking)"
        env:
          OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
          OSSRH_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}
      
      # Step 8: Verify publication
      - name: âœ… Verify Publication
        run: |
          echo "Verifying publication..."

          # Additional wait to ensure all processing is complete
          sleep 15

          # Check if deployment is visible in Central Publisher Portal
          CREDENTIALS=$(echo -n "${{ secrets.OSSRH_USERNAME }}:${{ secrets.OSSRH_PASSWORD }}" | base64)

          echo "Final verification of deployment status..."

          HTTP_CODE=$(curl -w "%{http_code}" -o final_search_response.txt -X GET \
            "https://ossrh-staging-api.central.sonatype.com/manual/search/repositories?profile_id=com.githubim&ip=any" \
            -H "Authorization: Bearer $CREDENTIALS" \
            -H "Accept: application/json")

          echo "Final search API HTTP response code: $HTTP_CODE"

          if [ "$HTTP_CODE" -eq 200 ]; then
            echo "Search response:"
            cat final_search_response.txt

            if grep -q '"repositories"' final_search_response.txt; then
              REPO_COUNT=$(grep -o '"key"' final_search_response.txt | wc -l)
              echo "âœ… Found $REPO_COUNT staging repositories"
              echo "âœ… Deployment is visible in the staging system"
            else
              echo "â„¹ï¸ No explicit staging repositories found"
              echo "â„¹ï¸ This is normal for Maven-like deployments"
              echo "â„¹ï¸ Check the Central Publisher Portal at: https://central.sonatype.com/publishing/deployments"
            fi
          else
            echo "âš ï¸ Could not verify deployment status (HTTP $HTTP_CODE)"
            echo "âš ï¸ Manual verification recommended at: https://central.sonatype.com/"
          fi

          echo ""
          echo "ðŸŽ‰ Publication process completed!"
          echo "ðŸ“‹ Next steps:"
          echo "   1. Check Central Publisher Portal: https://central.sonatype.com/publishing/deployments"
          echo "   2. Review and release the deployment if it appears there"
          echo "   3. Monitor Maven Central for the published artifact"

          echo "Publication verification completed"
      
      # Step 9: Clean up sensitive files
      - name: ðŸ§¹ Clean Up Sensitive Files
        if: always()
        run: |
          echo "Cleaning up sensitive files..."
          rm -f $HOME/private.key
          rm -f gradle.properties
          # Clean up GPG agent
          gpgconf --kill gpg-agent || true
          echo "Cleanup completed"

  # Job 3: Create GitHub Release
  create-release:
    name: ðŸŽ‰ Create GitHub Release
    runs-on: ubuntu-latest
    needs: [build-and-test, publish-maven]
    if: success()
    
    steps:
      # Step 1: Checkout repository
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      # Step 2: Download build artifacts
      - name: ðŸ“¦ Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: ./artifacts
      
      # Step 3: Generate release notes
      - name: ðŸ“ Generate Release Notes
        id: release-notes
        run: |
          VERSION="${{ needs.build-and-test.outputs.version }}"
          
          # Create release notes
          cat > release-notes.md << EOF
          ## ðŸš€ WuKongIM Android EasySDK v$VERSION
          
          ### ðŸ“¦ Installation
          
          Add to your app-level \`build.gradle\`:
          
          \`\`\`kotlin
          dependencies {
              implementation 'com.githubim:easysdk-android:$VERSION'
          }
          \`\`\`
          
          ### ðŸ”— Links
          
          - [ðŸ“š Documentation](https://github.com/WuKongIM/WuKongEasySDK-Android#readme)
          - [ðŸ› Report Issues](https://github.com/WuKongIM/WuKongEasySDK-Android/issues)
          - [ðŸ’¬ Discussions](https://github.com/WuKongIM/WuKongEasySDK-Android/discussions)
          - [ðŸ“¦ Maven Central](https://search.maven.org/artifact/com.githubim/easysdk-android/$VERSION)
          
          ### âœ… Verification
          
          This release has been:
          - âœ… Built and tested automatically
          - âœ… Published to Maven Central
          - âœ… Signed with GPG for security
          - âœ… Verified for integrity
          
          EOF
          
          echo "Release notes generated"
      
      # Step 4: Create GitHub Release
      - name: ðŸŽ‰ Create GitHub Release
        id: create-release
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ needs.build-and-test.outputs.version }}
          name: "Release v${{ needs.build-and-test.outputs.version }}"
          body_path: release-notes.md
          draft: false
          prerelease: ${{ needs.build-and-test.outputs.is-prerelease == 'true' }}
          files: |
            ./artifacts/**/*
          generate_release_notes: true

  # Job 4: Notify on Success/Failure
  notify:
    name: ðŸ“¢ Send Notifications
    runs-on: ubuntu-latest
    needs: [build-and-test, publish-maven, create-release]
    if: always()
    
    steps:
      # Step 1: Determine workflow status
      - name: ðŸ“Š Determine Status
        id: status
        run: |
          if [ "${{ needs.build-and-test.result }}" = "success" ] && \
             [ "${{ needs.publish-maven.result }}" = "success" ] && \
             [ "${{ needs.create-release.result }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=âœ… Successfully published WuKongIM Android EasySDK v${{ needs.build-and-test.outputs.version }} to Maven Central" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=âŒ Failed to publish WuKongIM Android EasySDK v${{ needs.build-and-test.outputs.version }}" >> $GITHUB_OUTPUT
          fi
      
      # Step 2: Create workflow summary
      - name: ðŸ“‹ Create Workflow Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ðŸ“¦ Maven Central Publishing Results
          
          ## ðŸ“Š Status: ${{ steps.status.outputs.status == 'success' && 'âœ… Success' || 'âŒ Failed' }}
          
          **Version**: ${{ needs.build-and-test.outputs.version }}
          **Prerelease**: ${{ needs.build-and-test.outputs.is-prerelease }}
          **Trigger**: ${{ github.event_name }}
          
          ## ðŸ”„ Job Results
          
          | Job | Status |
          |-----|--------|
          | Build and Test | ${{ needs.build-and-test.result == 'success' && 'âœ…' || 'âŒ' }} ${{ needs.build-and-test.result }} |
          | Publish Maven | ${{ needs.publish-maven.result == 'success' && 'âœ…' || needs.publish-maven.result == 'skipped' && 'â­ï¸' || 'âŒ' }} ${{ needs.publish-maven.result }} |
          | Create Release | ${{ needs.create-release.result == 'success' && 'âœ…' || needs.create-release.result == 'skipped' && 'â­ï¸' || 'âŒ' }} ${{ needs.create-release.result }} |
          
          ## ðŸ”— Links
          
          - [Maven Central](https://search.maven.org/artifact/com.githubim/easysdk-android/${{ needs.build-and-test.outputs.version }})
          - [GitHub Release](https://github.com/WuKongIM/WuKongEasySDK-Android/releases/tag/v${{ needs.build-and-test.outputs.version }})
          - [Documentation](https://github.com/WuKongIM/WuKongEasySDK-Android#readme)
          
          EOF
