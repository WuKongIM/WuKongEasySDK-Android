# WuKongIM Android EasySDK - Maven Central Publishing Workflow
# This workflow automates the publishing process to Maven Central repository
# Triggers on version tags (v*) and manual dispatch for testing

name: üì¶ Publish to Maven Central

on:
  # Trigger on version tags (e.g., v1.0.0, v1.2.3, v2.0.0-beta.1)
  push:
    tags:
      - 'v*'
  
  # Allow manual triggering for testing and emergency releases
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to publish (e.g., 1.0.0)'
        required: true
        type: string
      dry_run:
        description: 'Perform a dry run (build without publishing)'
        required: false
        type: boolean
        default: false

# Ensure only one publishing workflow runs at a time
concurrency:
  group: publish-maven
  cancel-in-progress: false

jobs:
  # Job 1: Build, Test, and Validate
  build-and-test:
    name: üî® Build and Test
    runs-on: ubuntu-latest
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      is-prerelease: ${{ steps.version.outputs.is-prerelease }}
      
    steps:
      # Step 1: Checkout the repository
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for proper version detection
      
      # Step 2: Extract version from tag or input
      - name: üè∑Ô∏è Extract Version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
            echo "Using manual version: $VERSION"
          else
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "Using tag version: $VERSION"
          fi
          
          # Check if this is a prerelease (contains alpha, beta, rc, or SNAPSHOT)
          if [[ "$VERSION" =~ (alpha|beta|rc|SNAPSHOT) ]]; then
            IS_PRERELEASE=true
            echo "Detected prerelease version"
          else
            IS_PRERELEASE=false
            echo "Detected stable release version"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "is-prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_ENV
      
      # Step 3: Set up Java JDK 17
      - name: ‚òï Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
      
      # Step 4: Cache Gradle dependencies for faster builds
      - name: üì¶ Cache Gradle Dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-
      
      # Step 5: Make Gradle wrapper executable
      - name: üîß Make Gradle Wrapper Executable
        run: chmod +x gradlew
      
      # Step 6: Validate Gradle wrapper
      - name: ‚úÖ Validate Gradle Wrapper
        uses: gradle/actions/wrapper-validation@v3
      
      # Step 7: Run unit tests
      - name: üß™ Run Unit Tests
        run: |
          echo "Running unit tests..."
          ./gradlew test --no-daemon --stacktrace
          echo "Unit tests completed successfully"
      
      # Step 8: Run lint checks
      - name: üîç Run Lint Checks
        run: |
          echo "Running lint analysis..."
          ./gradlew lint --no-daemon
          echo "Lint checks completed"
      
      # Step 9: Build the library and generate artifacts
      - name: üèóÔ∏è Build Library and Artifacts
        run: |
          echo "Building Android library..."
          ./gradlew clean build --no-daemon --stacktrace
          echo "Build completed successfully"
      
      # Step 10: Generate test coverage report (optional - requires JaCoCo plugin)
      - name: üìä Generate Coverage Report
        run: |
          echo "Skipping coverage report - JaCoCo plugin not configured"
          echo "To enable coverage reports, add JaCoCo plugin to build.gradle"
      
      # Step 11: Upload test results
      - name: üìã Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            build/reports/tests/
            build/reports/lint-results*.html

      # Step 12: Upload build artifacts
      - name: üì¶ Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            build/outputs/aar/
            build/libs/
          retention-days: 30

  # Job 2: Publish to Maven Central
  publish-maven:
    name: üöÄ Publish to Maven Central
    runs-on: ubuntu-latest
    needs: build-and-test
    if: success() && (github.event.inputs.dry_run != 'true')
    
    environment: 
      name: maven-central
      url: https://search.maven.org/artifact/com.githubim/easysdk-android
    
    steps:
      # Step 1: Checkout repository
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      # Step 2: Set up Java JDK 17
      - name: ‚òï Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
      
      # Step 3: Restore Gradle cache
      - name: üì¶ Restore Gradle Cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-
      
      # Step 4: Set version environment variable
      - name: üè∑Ô∏è Set Version
        run: |
          VERSION="${{ needs.build-and-test.outputs.version }}"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Publishing version: $VERSION"
      
      # Step 5: Configure GPG signing
      - name: üîê Configure GPG Signing
        run: |
          echo "Setting up GPG signing..."

          # Create .gnupg directory if it doesn't exist
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg

          # Create GPG key file from secret with proper error handling
          if [ -z "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "Error: GPG_PRIVATE_KEY secret is not set"
            exit 1
          fi

          # Decode base64 GPG private key
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | base64 --decode > $HOME/private.key

          # Verify the key file was created and has content
          if [ ! -s "$HOME/private.key" ]; then
            echo "Error: GPG private key file is empty after decoding"
            exit 1
          fi

          # Import the GPG key with verbose output for debugging
          echo "Importing GPG private key..."
          gpg --batch --yes --import $HOME/private.key

          # List imported keys to verify
          echo "Imported GPG keys:"
          gpg --list-secret-keys --keyid-format LONG

          # Set GPG configuration for non-interactive signing
          echo "use-agent" > ~/.gnupg/gpg.conf
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          echo "batch" >> ~/.gnupg/gpg.conf
          echo "no-tty" >> ~/.gnupg/gpg.conf

          # Configure GPG agent
          echo "allow-loopback-pinentry" > ~/.gnupg/gpg-agent.conf
          echo "default-cache-ttl 86400" >> ~/.gnupg/gpg-agent.conf
          echo "max-cache-ttl 86400" >> ~/.gnupg/gpg-agent.conf

          # Set proper permissions
          chmod 600 ~/.gnupg/gpg.conf
          chmod 600 ~/.gnupg/gpg-agent.conf

          # Restart GPG agent
          gpgconf --kill gpg-agent || true
          gpgconf --launch gpg-agent

          # Test GPG signing capability
          echo "Testing GPG signing capability..."
          echo "test content" > test-sign.txt

          if gpg --batch --yes --pinentry-mode loopback \
            --passphrase "${{ secrets.SIGNING_PASSWORD }}" \
            --armor --detach-sign \
            --default-key "${{ secrets.SIGNING_KEY_ID }}" \
            test-sign.txt; then
            echo "‚úÖ GPG signing test successful"

            # Verify the signature
            if gpg --verify test-sign.txt.asc test-sign.txt 2>/dev/null; then
              echo "‚úÖ GPG signature verification successful"
            else
              echo "‚ö†Ô∏è GPG signature verification failed"
            fi

            # Show signature content for debugging
            echo "üìã Generated signature content:"
            cat test-sign.txt.asc
          else
            echo "‚ùå GPG signing test failed"
            exit 1
          fi

          # Cleanup test files
          rm -f test-sign.txt test-sign.txt.asc

          echo "GPG signing configured and tested successfully"
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}
          SIGNING_KEY_ID: ${{ secrets.SIGNING_KEY_ID }}
      
      # Step 6: Create gradle.properties with signing configuration
      - name: üìù Configure Gradle Properties
        run: |
          echo "Creating gradle.properties with signing configuration..."

          cat > gradle.properties << EOF
          # Signing configuration
          signing.keyId=${{ secrets.SIGNING_KEY_ID }}
          signing.password=${{ secrets.SIGNING_PASSWORD }}

          # OSSRH credentials
          ossrhUsername=${{ secrets.OSSRH_USERNAME }}
          ossrhPassword=${{ secrets.OSSRH_PASSWORD }}

          # Android configuration
          android.useAndroidX=true
          kotlin.code.style=official
          android.nonTransitiveRClass=true

          # Gradle configuration
          org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
          org.gradle.parallel=true
          org.gradle.caching=true

          # GPG configuration for signing
          signing.gnupg.executable=gpg
          signing.gnupg.useLegacyGpg=false
          signing.gnupg.keyName=${{ secrets.SIGNING_KEY_ID }}
          signing.gnupg.passphrase=${{ secrets.SIGNING_PASSWORD }}
          EOF

          echo "Gradle properties configured"

      # Step 6.5: Portal API Health Check
      - name: üîó Portal API Health Check
        run: |
          echo "Verifying Portal API connectivity and permissions..."

          # Create base64 encoded credentials
          CREDENTIALS=$(echo -n "${{ secrets.OSSRH_USERNAME }}:${{ secrets.OSSRH_PASSWORD }}" | base64)

          # Test Portal API access
          echo "Testing Portal API access..."
          if curl -H "Authorization: Bearer $CREDENTIALS" \
            "https://central.sonatype.com/api/v1/publisher/deployments" \
            --fail --silent --max-time 30 > /dev/null; then
            echo "‚úÖ Portal API access confirmed"
            echo "portal_api_available=true" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è Portal API access issues detected - will use OSSRH Staging API only"
            echo "portal_api_available=false" >> $GITHUB_ENV
          fi

          # Check namespace access if Portal API is available
          if [ "${{ env.portal_api_available }}" != "false" ]; then
            echo "Checking namespace permissions..."
            NAMESPACES=$(curl -H "Authorization: Bearer $CREDENTIALS" \
              "https://central.sonatype.com/api/v1/publisher/namespaces" \
              --silent --max-time 30 | jq -r '.[].namespace' 2>/dev/null || echo "")

            if echo "$NAMESPACES" | grep -q "com.githubim"; then
              echo "‚úÖ Namespace com.githubim access confirmed"
            else
              echo "‚ö†Ô∏è Namespace access may be limited"
              echo "Available namespaces: $NAMESPACES"
            fi
          fi
        env:
          OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
          OSSRH_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}

      # Step 6.6: Create Portal API Bundle
      - name: üì¶ Create Portal API Bundle
        if: env.portal_api_available == 'true' && env.artifacts_signed == 'true'
        run: |
          echo "Creating Portal API deployment bundle..."

          # Use Maven local repository as source (contains signed artifacts)
          MAVEN_LOCAL_DIR="$HOME/.m2/repository/com/githubim/easysdk-android/$VERSION"

          # Run bundle creation script with Maven local repository
          ./scripts/create-portal-bundle.sh $VERSION "$MAVEN_LOCAL_DIR"

          # Verify bundle was created
          if [ -f "central-bundle.zip" ]; then
            BUNDLE_SIZE=$(du -h central-bundle.zip | cut -f1)
            echo "‚úÖ Bundle created successfully: central-bundle.zip ($BUNDLE_SIZE)"

            # Verify bundle contents include signatures
            echo "üìã Bundle contents:"
            unzip -l central-bundle.zip

            SIGNATURE_COUNT=$(unzip -l central-bundle.zip | grep -c "\.asc$" || echo "0")
            if [ "$SIGNATURE_COUNT" -gt 0 ]; then
              echo "‚úÖ Bundle contains $SIGNATURE_COUNT signature files"
              echo "bundle_created=true" >> $GITHUB_ENV
            else
              echo "‚ö†Ô∏è Bundle missing signature files - Portal API may reject it"
              echo "bundle_created=false" >> $GITHUB_ENV
            fi
          else
            echo "‚ùå Failed to create bundle"
            echo "bundle_created=false" >> $GITHUB_ENV
          fi

      # Step 6.7: Upload to Portal API (Primary Method)
      - name: üöÄ Upload to Portal API
        if: env.portal_api_available == 'true' && env.bundle_created == 'true'
        id: portal_upload
        continue-on-error: true
        run: |
          echo "Uploading to Portal API (Primary Method)..."

          # Create base64 encoded credentials
          CREDENTIALS=$(echo -n "${{ secrets.OSSRH_USERNAME }}:${{ secrets.OSSRH_PASSWORD }}" | base64)

          # Upload bundle to Portal API
          echo "Uploading bundle to Portal API..."

          # Capture both response and HTTP code
          UPLOAD_RESPONSE=$(curl -X POST \
            -H "Authorization: Bearer $CREDENTIALS" \
            -F "bundle=@central-bundle.zip" \
            -F "name=WuKongIM Android EasySDK v$VERSION" \
            "https://central.sonatype.com/api/v1/publisher/upload?publishingType=USER_MANAGED" \
            --silent --show-error --max-time 300 -w "%{http_code}")

          HTTP_CODE="${UPLOAD_RESPONSE: -3}"
          RESPONSE_BODY="${UPLOAD_RESPONSE%???}"

          echo "Portal API HTTP Code: $HTTP_CODE"
          echo "Portal API Response: $RESPONSE_BODY"

          if [ "$HTTP_CODE" = "201" ] && [ -n "$RESPONSE_BODY" ] && [ "$RESPONSE_BODY" != "null" ]; then
            DEPLOYMENT_ID="$RESPONSE_BODY"
            echo "‚úÖ Portal API upload successful"
            echo "Deployment ID: $DEPLOYMENT_ID"
            echo "portal_deployment_id=$DEPLOYMENT_ID" >> $GITHUB_ENV
            echo "portal_upload_success=true" >> $GITHUB_ENV

            # Monitor deployment status
            echo "Monitoring deployment status..."
            for i in {1..10}; do
              STATUS=$(curl -X POST \
                -H "Authorization: Bearer $CREDENTIALS" \
                "https://central.sonatype.com/api/v1/publisher/status?id=$DEPLOYMENT_ID" \
                --silent | jq -r '.deploymentState' 2>/dev/null || echo "UNKNOWN")

              echo "Status check $i: $STATUS"

              case $STATUS in
                "VALIDATED")
                  echo "‚úÖ Deployment validated and ready for manual release"
                  echo "üîó View at: https://central.sonatype.com/publishing/deployments"
                  break
                  ;;
                "PUBLISHED")
                  echo "üéâ Deployment automatically published to Maven Central"
                  break
                  ;;
                "FAILED")
                  echo "‚ùå Deployment failed validation"
                  curl -X POST \
                    -H "Authorization: Bearer $CREDENTIALS" \
                    "https://central.sonatype.com/api/v1/publisher/status?id=$DEPLOYMENT_ID" \
                    --silent | jq '.errors' 2>/dev/null || echo "No error details available"
                  echo "portal_upload_success=false" >> $GITHUB_ENV
                  break
                  ;;
                "PENDING"|"VALIDATING"|"PUBLISHING")
                  echo "‚è≥ Deployment in progress: $STATUS"
                  if [ $i -eq 10 ]; then
                    echo "‚è∞ Monitoring timeout - check Portal manually"
                    echo "üîó View at: https://central.sonatype.com/publishing/deployments"
                  else
                    sleep 30
                  fi
                  ;;
                *)
                  echo "‚ùì Unknown status: $STATUS"
                  sleep 30
                  ;;
              esac
            done
          else
            echo "‚ùå Portal API upload failed"
            echo "HTTP Code: $HTTP_CODE"
            echo "Response: $RESPONSE_BODY"

            # Check for specific error types
            if echo "$RESPONSE_BODY" | grep -q "Invalid signature"; then
              echo "üîç Signature validation error detected"
              echo "üìã This indicates GPG signing issues in the bundle"
              echo "üîß Bundle will be recreated with OSSRH method as fallback"
            elif [ "$HTTP_CODE" = "401" ]; then
              echo "üîê Authentication error - check Portal credentials"
            elif [ "$HTTP_CODE" = "400" ]; then
              echo "üì¶ Bundle format error - check bundle contents"
            fi

            echo "portal_upload_success=false" >> $GITHUB_ENV
          fi
        env:
          OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
          OSSRH_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}

      # Step 7: Build and Sign Artifacts
      - name: üîê Build and Sign Artifacts
        run: |
          echo "Building and signing all artifacts..."
          echo "Version: $VERSION"

          # Build and sign all artifacts including sources and javadoc
          ./gradlew clean build \
            androidSourcesJar \
            androidJavadocJar \
            publishToMavenLocal \
            --no-daemon \
            --stacktrace \
            --info \
            -Pversion=$VERSION

          echo "‚úÖ All artifacts built and signed successfully"

          # Verify signed artifacts exist in Maven local repository
          MAVEN_LOCAL_DIR="$HOME/.m2/repository/com/githubim/easysdk-android/$VERSION"
          echo "Checking signed artifacts in: $MAVEN_LOCAL_DIR"

          if [ -d "$MAVEN_LOCAL_DIR" ]; then
            echo "üì¶ Artifacts in Maven local repository:"
            ls -la "$MAVEN_LOCAL_DIR"

            # Check for signature files
            SIGNATURE_COUNT=$(find "$MAVEN_LOCAL_DIR" -name "*.asc" | wc -l)
            echo "Found $SIGNATURE_COUNT signature files"

            if [ "$SIGNATURE_COUNT" -gt 0 ]; then
              echo "‚úÖ GPG signatures found:"
              find "$MAVEN_LOCAL_DIR" -name "*.asc" -exec basename {} \;
              echo "artifacts_signed=true" >> $GITHUB_ENV
            else
              echo "‚ö†Ô∏è No GPG signatures found - signing may have failed"
              echo "artifacts_signed=false" >> $GITHUB_ENV
            fi
          else
            echo "‚ùå Maven local repository directory not found"
            echo "artifacts_signed=false" >> $GITHUB_ENV
          fi
        env:
          OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
          OSSRH_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}
          SIGNING_KEY_ID: ${{ secrets.SIGNING_KEY_ID }}
          SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}

      # Step 8: Publish to Maven Central Staging (Fallback Method)
      - name: üì§ Publish to Maven Central Staging (Fallback)
        if: (env.portal_api_available != 'true' || env.portal_upload_success != 'true') && env.artifacts_signed == 'true'
        run: |
          if [ "${{ env.portal_upload_success }}" = "true" ]; then
            echo "‚ÑπÔ∏è Portal API upload succeeded - skipping OSSRH Staging API"
            echo "‚úÖ Using Portal API as primary publishing method"
            exit 0
          fi

          echo "üì§ Publishing to Maven Central staging repository (Fallback Method)..."
          echo "Version: $VERSION"

          if [ "${{ env.portal_api_available }}" != "true" ]; then
            echo "‚ö†Ô∏è Portal API not available - using OSSRH Staging API as primary method"
          else
            echo "‚ö†Ô∏è Portal API upload failed - using OSSRH Staging API as fallback"
          fi

          # Verify artifacts are signed before publishing
          MAVEN_LOCAL_DIR="$HOME/.m2/repository/com/githubim/easysdk-android/$VERSION"
          SIGNATURE_COUNT=$(find "$MAVEN_LOCAL_DIR" -name "*.asc" | wc -l)

          if [ "$SIGNATURE_COUNT" -eq 0 ]; then
            echo "‚ùå No signed artifacts found - cannot publish to OSSRH"
            echo "ossrh_upload_success=false" >> $GITHUB_ENV
            exit 1
          fi

          echo "‚úÖ Found $SIGNATURE_COUNT signed artifacts, proceeding with OSSRH publication"

          # Publish to staging repository (using already signed artifacts)
          ./gradlew publishReleasePublicationToOSSRHRepository \
            --no-daemon \
            --stacktrace \
            --info \
            -Pversion=$VERSION

          echo "‚úÖ Successfully published to staging repository"
          echo "ossrh_upload_success=true" >> $GITHUB_ENV
        env:
          OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
          OSSRH_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}
          SIGNING_KEY_ID: ${{ secrets.SIGNING_KEY_ID }}
          SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}

      # Step 8.5: Verify OSSRH Upload Signatures
      - name: üîç Verify OSSRH Upload Signatures
        if: env.ossrh_upload_success == 'true'
        run: |
          echo "Verifying that OSSRH upload included valid signatures..."

          # Check local Maven repository for signed artifacts
          MAVEN_LOCAL_DIR="$HOME/.m2/repository/com/githubim/easysdk-android/$VERSION"

          echo "Checking signatures in: $MAVEN_LOCAL_DIR"
          ls -la "$MAVEN_LOCAL_DIR"

          # Verify signature files exist and are valid
          SIGNATURE_FILES=$(find "$MAVEN_LOCAL_DIR" -name "*.asc")
          VALID_SIGNATURES=0

          for sig_file in $SIGNATURE_FILES; do
            if [ -f "$sig_file" ] && [ -s "$sig_file" ]; then
              if head -1 "$sig_file" | grep -q "BEGIN PGP SIGNATURE"; then
                echo "‚úÖ Valid signature: $(basename "$sig_file")"
                VALID_SIGNATURES=$((VALID_SIGNATURES + 1))
              else
                echo "‚ùå Invalid signature: $(basename "$sig_file")"
                echo "Content: $(head -1 "$sig_file")"
              fi
            else
              echo "‚ùå Empty or missing signature: $(basename "$sig_file")"
            fi
          done

          echo "Found $VALID_SIGNATURES valid signatures"

          if [ "$VALID_SIGNATURES" -lt 4 ]; then
            echo "‚ö†Ô∏è Insufficient valid signatures for Portal deployment"
            echo "‚ö†Ô∏è Expected at least 4 valid signatures, found: $VALID_SIGNATURES"
            echo "‚ö†Ô∏è Portal deployment will be skipped to avoid validation errors"
            echo "üîß Recommendation: Check GPG signing configuration and regenerate artifacts"
            echo "ossrh_signatures_valid=false" >> $GITHUB_ENV
          else
            echo "‚úÖ All required signatures are valid ($VALID_SIGNATURES/4+)"
            echo "‚úÖ Portal deployment can proceed safely"
            echo "ossrh_signatures_valid=true" >> $GITHUB_ENV
          fi

      # Step 8.6: Skip Portal Deployment if Signatures Invalid
      - name: ‚ö†Ô∏è Skip Portal Deployment (Invalid Signatures)
        if: env.ossrh_upload_success == 'true' && env.ossrh_signatures_valid != 'true'
        run: |
          echo "üö´ Skipping Portal deployment due to invalid signatures"
          echo "üìã This prevents the 400 error you encountered previously"
          echo ""
          echo "üîç Issue Analysis:"
          echo "   - OSSRH upload succeeded but signatures are invalid"
          echo "   - Portal API would reject these signatures with 400 error"
          echo "   - Skipping Portal trigger to avoid known failure"
          echo ""
          echo "üîß Resolution Steps:"
          echo "   1. Check GPG_PRIVATE_KEY secret is correctly formatted"
          echo "   2. Verify SIGNING_KEY_ID matches the imported key"
          echo "   3. Ensure SIGNING_PASSWORD is correct"
          echo "   4. Re-run workflow after fixing GPG configuration"
          echo ""
          echo "üìû Alternative: Use Portal API method instead of OSSRH fallback"

      # Step 9: Trigger deployment visibility in Central Publisher Portal (OSSRH Only)
      - name: üîÑ Trigger Portal Deployment (OSSRH Method)
        if: env.ossrh_upload_success == 'true' && env.ossrh_signatures_valid == 'true'
        continue-on-error: true  # Don't fail the workflow if this step fails
        run: |
          echo "Triggering deployment visibility in Central Publisher Portal..."
          echo "‚ö†Ô∏è Note: Using OSSRH Staging API method (fallback)"

          # Wait for the deployment to be processed by the staging API
          echo "Waiting for deployment to be processed..."
          sleep 30

          # Create base64 encoded credentials for API authentication
          CREDENTIALS=$(echo -n "${{ secrets.OSSRH_USERNAME }}:${{ secrets.OSSRH_PASSWORD }}" | base64)

          echo "Searching for staging repositories first..."

          # First, search for any existing staging repositories
          SEARCH_HTTP_CODE=$(curl -w "%{http_code}" -o search_response.txt -X GET \
            "https://ossrh-staging-api.central.sonatype.com/manual/search/repositories?profile_id=com.githubim&ip=any" \
            -H "Authorization: Bearer $CREDENTIALS" \
            -H "Accept: application/json")

          echo "Search HTTP response code: $SEARCH_HTTP_CODE"

          if [ "$SEARCH_HTTP_CODE" -eq 200 ]; then
            echo "Search response:"
            cat search_response.txt

            # Check if we have any repositories
            if grep -q '"repositories"' search_response.txt && grep -q '"key"' search_response.txt; then
              echo "Found staging repositories, analyzing repository states..."

              # Parse repositories and find suitable candidates for portal deployment
              echo "Repository analysis:"
              grep -o '"key":"[^"]*","state":"[^"]*","description":[^,]*,"portal_deployment_id":[^}]*' search_response.txt | while IFS= read -r repo_info; do
                REPO_KEY=$(echo "$repo_info" | grep -o '"key":"[^"]*"' | sed 's/"key":"\([^"]*\)"/\1/')
                REPO_STATE=$(echo "$repo_info" | grep -o '"state":"[^"]*"' | sed 's/"state":"\([^"]*\)"/\1/')
                PORTAL_ID=$(echo "$repo_info" | grep -o '"portal_deployment_id":[^,}]*' | sed 's/"portal_deployment_id":\([^,}]*\)/\1/')

                echo "  Repository: $REPO_KEY"
                echo "  State: $REPO_STATE"
                echo "  Portal ID: $PORTAL_ID"
                echo ""
              done

              # Find the best repository for portal deployment
              # Priority: open state without portal_deployment_id
              BEST_REPO_KEY=""
              BEST_REPO_STATE=""

              # Look for open repositories without portal_deployment_id first
              while IFS= read -r repo_info; do
                REPO_KEY=$(echo "$repo_info" | grep -o '"key":"[^"]*"' | sed 's/"key":"\([^"]*\)"/\1/')
                REPO_STATE=$(echo "$repo_info" | grep -o '"state":"[^"]*"' | sed 's/"state":"\([^"]*\)"/\1/')
                PORTAL_ID=$(echo "$repo_info" | grep -o '"portal_deployment_id":[^,}]*' | sed 's/"portal_deployment_id":\([^,}]*\)/\1/')

                if [ "$REPO_STATE" = "open" ] && [ "$PORTAL_ID" = "null" ]; then
                  BEST_REPO_KEY="$REPO_KEY"
                  BEST_REPO_STATE="$REPO_STATE"
                  echo "‚úÖ Found suitable repository for portal deployment: $REPO_KEY (state: $REPO_STATE)"
                  break
                fi
              done < <(grep -o '"key":"[^"]*","state":"[^"]*","description":[^,]*,"portal_deployment_id":[^}]*' search_response.txt)

              if [ -n "$BEST_REPO_KEY" ]; then
                echo "Attempting portal deployment with repository: $BEST_REPO_KEY"

                # Try to trigger portal deployment using the selected repository
                UPLOAD_HTTP_CODE=$(curl -w "%{http_code}" -o upload_response.txt -X POST \
                  "https://ossrh-staging-api.central.sonatype.com/manual/upload/repository/$BEST_REPO_KEY?publishing_type=user_managed" \
                  -H "Authorization: Bearer $CREDENTIALS" \
                  -H "Accept: application/json")

                echo "Upload HTTP response code: $UPLOAD_HTTP_CODE"
                echo "Upload response:"
                cat upload_response.txt

                case $UPLOAD_HTTP_CODE in
                  200|201|202)
                    echo "‚úÖ Successfully triggered portal deployment"
                    ;;
                  400)
                    ERROR_MSG=$(cat upload_response.txt)
                    if echo "$ERROR_MSG" | grep -q "No objects found"; then
                      echo "‚ö†Ô∏è Repository exists but no artifacts found yet"
                      echo "‚ÑπÔ∏è This is normal - artifacts may still be uploading"
                      echo "‚ÑπÔ∏è The deployment should appear in Portal once upload completes"
                    elif echo "$ERROR_MSG" | grep -q "No repository found"; then
                      echo "‚ö†Ô∏è Repository not accessible or already processed"
                      echo "‚ÑπÔ∏è Check Central Publisher Portal for deployment status"
                    else
                      echo "‚ö†Ô∏è Portal deployment returned 400: $ERROR_MSG"
                    fi
                    ;;
                  *)
                    echo "‚ö†Ô∏è Portal deployment trigger returned HTTP $UPLOAD_HTTP_CODE"
                    echo "‚ÑπÔ∏è This may be normal - check Central Publisher Portal"
                    ;;
                esac
              else
                echo "‚ÑπÔ∏è No suitable repositories found for portal deployment"
                echo "‚ÑπÔ∏è Reasons could be:"
                echo "   - All repositories are already closed or processed"
                echo "   - All repositories already have portal_deployment_id"
                echo "   - Deployment is being processed automatically"
                echo ""
                echo "‚ÑπÔ∏è This is often normal for Maven-like deployments"
                echo "‚ÑπÔ∏è Check Central Publisher Portal: https://central.sonatype.com/publishing/deployments"
              fi
            else
              echo "‚ÑπÔ∏è No staging repositories found yet"
              echo "This is normal for Maven-like deployments - they may not create explicit staging repositories"
              echo "The deployment should still be visible in the Central Publisher Portal"
            fi
          else
            echo "‚ö†Ô∏è Could not search for repositories (HTTP $SEARCH_HTTP_CODE)"
            echo "This may indicate authentication issues or the namespace is not yet available"
          fi

          echo "Portal deployment step completed (non-blocking)"
        env:
          OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
          OSSRH_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}
      
      # Step 8: Verify publication
      - name: ‚úÖ Verify Publication
        run: |
          echo "Verifying publication..."

          # Additional wait to ensure all processing is complete
          sleep 15

          # Check if deployment is visible in Central Publisher Portal
          CREDENTIALS=$(echo -n "${{ secrets.OSSRH_USERNAME }}:${{ secrets.OSSRH_PASSWORD }}" | base64)

          echo "Final verification of deployment status..."

          HTTP_CODE=$(curl -w "%{http_code}" -o final_search_response.txt -X GET \
            "https://ossrh-staging-api.central.sonatype.com/manual/search/repositories?profile_id=com.githubim&ip=any" \
            -H "Authorization: Bearer $CREDENTIALS" \
            -H "Accept: application/json")

          echo "Final search API HTTP response code: $HTTP_CODE"

          if [ "$HTTP_CODE" -eq 200 ]; then
            echo "Search response:"
            cat final_search_response.txt

            if grep -q '"repositories"' final_search_response.txt; then
              REPO_COUNT=$(grep -o '"key"' final_search_response.txt | wc -l)
              echo "‚úÖ Found $REPO_COUNT staging repositories"
              echo "‚úÖ Deployment is visible in the staging system"
            else
              echo "‚ÑπÔ∏è No explicit staging repositories found"
              echo "‚ÑπÔ∏è This is normal for Maven-like deployments"
              echo "‚ÑπÔ∏è Check the Central Publisher Portal at: https://central.sonatype.com/publishing/deployments"
            fi
          else
            echo "‚ö†Ô∏è Could not verify deployment status (HTTP $HTTP_CODE)"
            echo "‚ö†Ô∏è Manual verification recommended at: https://central.sonatype.com/"
          fi

          echo ""
          echo "üéâ Publication process completed!"
          echo "üìã Next steps:"
          echo "   1. Check Central Publisher Portal: https://central.sonatype.com/publishing/deployments"
          echo "   2. Review and release the deployment if it appears there"
          echo "   3. Monitor Maven Central for the published artifact"

          echo "Publication verification completed"

      # Step 9: Final Status Report
      - name: üìä Final Publishing Status Report
        if: always()
        run: |
          echo ""
          echo "üéØ PUBLISHING STATUS REPORT"
          echo "================================"
          echo ""

          # Portal API Status
          if [ "${{ env.portal_api_available }}" = "true" ]; then
            echo "üîó Portal API: ‚úÖ Available"
            if [ "${{ env.portal_upload_success }}" = "true" ]; then
              echo "üì¶ Portal Upload: ‚úÖ Successful"
              if [ -n "${{ env.portal_deployment_id }}" ]; then
                echo "üÜî Deployment ID: ${{ env.portal_deployment_id }}"
              fi
              echo "üéØ Primary Method: Portal API"
            else
              echo "üì¶ Portal Upload: ‚ùå Failed"
            fi
          else
            echo "üîó Portal API: ‚ö†Ô∏è Not Available"
          fi

          # OSSRH Status
          if [ "${{ env.ossrh_upload_success }}" = "true" ]; then
            echo "üì§ OSSRH Upload: ‚úÖ Successful"
            if [ "${{ env.portal_upload_success }}" != "true" ]; then
              echo "üéØ Primary Method: OSSRH Staging API"
            else
              echo "üéØ Fallback Method: Not Used"
            fi
          else
            if [ "${{ env.portal_upload_success }}" != "true" ]; then
              echo "üì§ OSSRH Upload: ‚ùå Failed"
            else
              echo "üì§ OSSRH Upload: ‚è≠Ô∏è Skipped (Portal API succeeded)"
            fi
          fi

          echo ""
          echo "üìã NEXT STEPS:"

          if [ "${{ env.portal_upload_success }}" = "true" ]; then
            echo "‚úÖ Portal API Method Used:"
            echo "   1. üîó Visit: https://central.sonatype.com/publishing/deployments"
            echo "   2. üîç Find deployment: WuKongIM Android EasySDK v$VERSION"
            echo "   3. ‚úÖ Review validation results"
            echo "   4. üöÄ Manually release to Maven Central (if validated)"
            echo "   5. üìä Monitor release progress"
          elif [ "${{ env.ossrh_upload_success }}" = "true" ]; then
            echo "‚ö†Ô∏è OSSRH Staging API Method Used (Fallback):"
            echo "   1. üîó Visit: https://central.sonatype.com/publishing/deployments"
            echo "   2. üîç Look for deployment in Portal (may take time to appear)"
            echo "   3. ‚úÖ Review validation results"
            echo "   4. üöÄ Manually release to Maven Central"
            echo "   5. ‚ö†Ô∏è Consider migrating to Portal API for future releases"
          else
            echo "‚ùå Both Methods Failed:"
            echo "   1. üîç Review workflow logs for errors"
            echo "   2. üîê Verify authentication credentials"
            echo "   3. üåê Check network connectivity"
            echo "   4. üìû Contact support if issues persist"
          fi

          echo ""
          echo "üîó USEFUL LINKS:"
          echo "   ‚Ä¢ Central Publisher Portal: https://central.sonatype.com/publishing/deployments"
          echo "   ‚Ä¢ Maven Central Search: https://search.maven.org/artifact/com.githubim/easysdk-android"
          echo "   ‚Ä¢ Documentation: https://central.sonatype.org/publish/"
          echo "   ‚Ä¢ Support: central-support@sonatype.com"

          echo ""
          echo "‚ö†Ô∏è MIGRATION REMINDER:"
          echo "   OSSRH will sunset on June 30, 2025"
          echo "   Migrate to Portal API before this date"
          echo "   Current status: $( [ "${{ env.portal_api_available }}" = "true" ] && echo "‚úÖ Ready for Portal API" || echo "‚ö†Ô∏è Portal API setup needed" )"

          echo ""
          echo "üéâ Publishing workflow completed!"
      
      # Step 9: Clean up sensitive files
      - name: üßπ Clean Up Sensitive Files
        if: always()
        run: |
          echo "Cleaning up sensitive files..."
          rm -f $HOME/private.key
          rm -f gradle.properties
          # Clean up GPG agent
          gpgconf --kill gpg-agent || true
          echo "Cleanup completed"

  # Job 3: Create GitHub Release
  create-release:
    name: üéâ Create GitHub Release
    runs-on: ubuntu-latest
    needs: [build-and-test, publish-maven]
    if: success()
    
    steps:
      # Step 1: Checkout repository
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      # Step 2: Download build artifacts
      - name: üì¶ Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: ./artifacts
      
      # Step 3: Generate release notes
      - name: üìù Generate Release Notes
        id: release-notes
        run: |
          VERSION="${{ needs.build-and-test.outputs.version }}"
          
          # Create release notes
          cat > release-notes.md << EOF
          ## üöÄ WuKongIM Android EasySDK v$VERSION
          
          ### üì¶ Installation
          
          Add to your app-level \`build.gradle\`:
          
          \`\`\`kotlin
          dependencies {
              implementation 'com.githubim:easysdk-android:$VERSION'
          }
          \`\`\`
          
          ### üîó Links
          
          - [üìö Documentation](https://github.com/WuKongIM/WuKongEasySDK-Android#readme)
          - [üêõ Report Issues](https://github.com/WuKongIM/WuKongEasySDK-Android/issues)
          - [üí¨ Discussions](https://github.com/WuKongIM/WuKongEasySDK-Android/discussions)
          - [üì¶ Maven Central](https://search.maven.org/artifact/com.githubim/easysdk-android/$VERSION)
          
          ### ‚úÖ Verification
          
          This release has been:
          - ‚úÖ Built and tested automatically
          - ‚úÖ Published to Maven Central
          - ‚úÖ Signed with GPG for security
          - ‚úÖ Verified for integrity
          
          EOF
          
          echo "Release notes generated"
      
      # Step 4: Create GitHub Release
      - name: üéâ Create GitHub Release
        id: create-release
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ needs.build-and-test.outputs.version }}
          name: "Release v${{ needs.build-and-test.outputs.version }}"
          body_path: release-notes.md
          draft: false
          prerelease: ${{ needs.build-and-test.outputs.is-prerelease == 'true' }}
          files: |
            ./artifacts/**/*
          generate_release_notes: true

  # Job 4: Notify on Success/Failure
  notify:
    name: üì¢ Send Notifications
    runs-on: ubuntu-latest
    needs: [build-and-test, publish-maven, create-release]
    if: always()
    
    steps:
      # Step 1: Determine workflow status
      - name: üìä Determine Status
        id: status
        run: |
          if [ "${{ needs.build-and-test.result }}" = "success" ] && \
             [ "${{ needs.publish-maven.result }}" = "success" ] && \
             [ "${{ needs.create-release.result }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=‚úÖ Successfully published WuKongIM Android EasySDK v${{ needs.build-and-test.outputs.version }} to Maven Central" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=‚ùå Failed to publish WuKongIM Android EasySDK v${{ needs.build-and-test.outputs.version }}" >> $GITHUB_OUTPUT
          fi
      
      # Step 2: Create workflow summary
      - name: üìã Create Workflow Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # üì¶ Maven Central Publishing Results
          
          ## üìä Status: ${{ steps.status.outputs.status == 'success' && '‚úÖ Success' || '‚ùå Failed' }}
          
          **Version**: ${{ needs.build-and-test.outputs.version }}
          **Prerelease**: ${{ needs.build-and-test.outputs.is-prerelease }}
          **Trigger**: ${{ github.event_name }}
          
          ## üîÑ Job Results
          
          | Job | Status |
          |-----|--------|
          | Build and Test | ${{ needs.build-and-test.result == 'success' && '‚úÖ' || '‚ùå' }} ${{ needs.build-and-test.result }} |
          | Publish Maven | ${{ needs.publish-maven.result == 'success' && '‚úÖ' || needs.publish-maven.result == 'skipped' && '‚è≠Ô∏è' || '‚ùå' }} ${{ needs.publish-maven.result }} |
          | Create Release | ${{ needs.create-release.result == 'success' && '‚úÖ' || needs.create-release.result == 'skipped' && '‚è≠Ô∏è' || '‚ùå' }} ${{ needs.create-release.result }} |
          
          ## üîó Links
          
          - [Maven Central](https://search.maven.org/artifact/com.githubim/easysdk-android/${{ needs.build-and-test.outputs.version }})
          - [GitHub Release](https://github.com/WuKongIM/WuKongEasySDK-Android/releases/tag/v${{ needs.build-and-test.outputs.version }})
          - [Documentation](https://github.com/WuKongIM/WuKongEasySDK-Android#readme)
          
          EOF
