# WuKongIM Android EasySDK - Modern Portal API Publishing Workflow
# Streamlined workflow using only Central Publisher Portal API
# Generates all required artifacts with checksums and signatures

name: üì¶ Publish to Maven Central via Portal API

on:
  # Trigger on version tags (e.g., v1.0.0, v1.2.3, v2.0.0-beta.1)
  push:
    tags:
      - 'v*'
  
  # Allow manual triggering for testing and emergency releases
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to publish (e.g., 1.0.0)'
        required: true
        type: string
      dry_run:
        description: 'Perform a dry run (build without publishing)'
        required: false
        type: boolean
        default: false

# Ensure only one publishing workflow runs at a time
concurrency:
  group: publish-maven-portal
  cancel-in-progress: false

jobs:
  publish:
    name: üöÄ Build and Publish to Maven Central
    runs-on: ubuntu-latest
    if: github.event.inputs.dry_run != 'true'
    
    environment: 
      name: maven-central
      url: https://search.maven.org/artifact/com.githubim/easysdk-android
    
    steps:
      # Step 1: Checkout the repository
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for proper version detection
      
      # Step 2: Extract version from tag or input
      - name: üè∑Ô∏è Extract Version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
            echo "Using manual version: $VERSION"
          else
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "Using tag version: $VERSION"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Publishing version: $VERSION"
      
      # Step 3: Set up Java JDK 17
      - name: ‚òï Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
      
      # Step 4: Cache Gradle dependencies
      - name: üì¶ Cache Gradle Dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-
      
      # Step 5: Make Gradle wrapper executable
      - name: üîß Make Gradle Wrapper Executable
        run: chmod +x gradlew
      
      # Step 6: Validate Gradle wrapper
      - name: ‚úÖ Validate Gradle Wrapper
        uses: gradle/actions/wrapper-validation@v3
      
      # Step 7: Configure GPG signing
      - name: üîê Configure GPG Signing
        run: |
          echo "Setting up GPG signing..."

          # Create .gnupg directory if it doesn't exist
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg

          # Verify all required secrets are present
          if [ -z "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "Error: GPG_PRIVATE_KEY secret is not set"
            exit 1
          fi

          if [ -z "${{ secrets.SIGNING_KEY_ID }}" ]; then
            echo "Error: SIGNING_KEY_ID secret is not set"
            exit 1
          fi

          if [ -z "${{ secrets.SIGNING_PASSWORD }}" ]; then
            echo "Error: SIGNING_PASSWORD secret is not set"
            exit 1
          fi

          echo "All GPG secrets are present"

          # Decode base64 GPG private key
          echo "Decoding GPG private key..."
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | base64 --decode > $HOME/private.key

          # Verify the key file was created and has content
          if [ ! -s "$HOME/private.key" ]; then
            echo "Error: GPG private key file is empty after decoding"
            exit 1
          fi


          echo "GPG private key decoded successfully"

          # Import the GPG key with verbose output
          echo "Importing GPG private key..."
          if gpg --batch --yes --import $HOME/private.key; then
            echo "‚úÖ GPG key imported successfully"
          else
            echo "‚ùå Failed to import GPG key"
            exit 1
          fi
          
          # List imported keys to verify
          echo "Imported GPG keys:"
          gpg --list-secret-keys --keyid-format LONG

          # Verify the specific key ID exists
          echo "Verifying key ID ${{ secrets.SIGNING_KEY_ID }}..."
          if gpg --list-secret-keys --keyid-format LONG | grep -q "${{ secrets.SIGNING_KEY_ID }}"; then
            echo "‚úÖ Key ID ${{ secrets.SIGNING_KEY_ID }} found in keyring"
          else
            echo "‚ùå Key ID ${{ secrets.SIGNING_KEY_ID }} not found in keyring"
            echo "Available key IDs:"
            gpg --list-secret-keys --keyid-format LONG | grep "sec" || echo "No secret keys found"
            exit 1
          fi

          # Set GPG configuration for non-interactive signing
          echo "Configuring GPG for non-interactive signing..."
          cat > ~/.gnupg/gpg.conf << EOF
          use-agent
          pinentry-mode loopback
          batch
          no-tty
          trust-model always
          EOF

          # Configure GPG agent
          cat > ~/.gnupg/gpg-agent.conf << EOF
          allow-loopback-pinentry
          default-cache-ttl 86400
          max-cache-ttl 86400
          pinentry-program /usr/bin/pinentry-curses
          EOF

          # Set proper permissions
          chmod 600 ~/.gnupg/gpg.conf
          chmod 600 ~/.gnupg/gpg-agent.conf

          # Restart GPG agent
          echo "Restarting GPG agent..."
          gpgconf --kill gpg-agent || true
          sleep 2
          gpgconf --launch gpg-agent

          # Verify GPG agent is running
          if gpgconf --list-components | grep -q "gpg-agent"; then
            echo "‚úÖ GPG agent is running"
          else
            echo "‚ö†Ô∏è GPG agent status unclear"
          fi
          
          # Test GPG signing capability with comprehensive validation
          echo "Testing GPG signing capability..."
          echo "test content for GPG signing validation" > test-sign.txt

          # Test signing with explicit parameters
          echo "Attempting to sign test file..."
          if gpg --batch --yes --pinentry-mode loopback \
            --passphrase "${{ secrets.SIGNING_PASSWORD }}" \
            --armor --detach-sign \
            --default-key "${{ secrets.SIGNING_KEY_ID }}" \
            --output test-sign.txt.asc \
            test-sign.txt; then
            echo "‚úÖ GPG signing test successful"

            # Verify the signature file was created and has content
            if [ -s "test-sign.txt.asc" ]; then
              echo "‚úÖ Signature file created with content"

              # Check signature file format
              if head -1 test-sign.txt.asc | grep -q "BEGIN PGP SIGNATURE"; then
                echo "‚úÖ Signature file has correct PGP format"

                # Display signature file for debugging
                echo "üìã Signature file content:"
                cat test-sign.txt.asc

                # Verify the signature
                echo "Verifying signature..."
                if gpg --verify test-sign.txt.asc test-sign.txt 2>&1; then
                  echo "‚úÖ GPG signature verification successful"
                else
                  echo "‚ùå GPG signature verification failed"
                  echo "This may indicate a problem with the signing process"
                  exit 1
                fi
              else
                echo "‚ùå Signature file doesn't have correct PGP format"
                echo "Signature file content:"
                cat test-sign.txt.asc
                exit 1
              fi
            else
              echo "‚ùå Signature file was not created or is empty"
              exit 1
            fi
          else
            echo "‚ùå GPG signing test failed"
            echo "Possible causes:"
            echo "  - Incorrect SIGNING_KEY_ID"
            echo "  - Incorrect SIGNING_PASSWORD"
            echo "  - GPG key not properly imported"
            echo "  - GPG agent configuration issues"
            exit 1
          fi

          # Test signing with different parameters to ensure compatibility
          echo "Testing alternative signing method..."
          echo "alternative test content" > test-sign2.txt

          if gpg --batch --yes --pinentry-mode loopback \
            --passphrase "${{ secrets.SIGNING_PASSWORD }}" \
            --armor --detach-sign \
            --local-user "${{ secrets.SIGNING_KEY_ID }}" \
            test-sign2.txt; then
            echo "‚úÖ Alternative signing method also works"
          else
            echo "‚ö†Ô∏è Alternative signing method failed (may not be critical)"
          fi

          # Cleanup test files
          rm -f test-sign.txt test-sign.txt.asc test-sign2.txt test-sign2.txt.asc

          echo "GPG signing configured and tested successfully"
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}
          SIGNING_KEY_ID: ${{ secrets.SIGNING_KEY_ID }}

      # # Step 7.5: Run comprehensive GPG diagnostics
      # - name: üîç Run GPG Diagnostics
      #   run: |
      #     echo "Running comprehensive GPG diagnostics..."
      #     chmod +x scripts/diagnose-gpg-signing.sh
      #     ./scripts/diagnose-gpg-signing.sh
      #   env:
      #     GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
      #     SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}
      #     SIGNING_KEY_ID: ${{ secrets.SIGNING_KEY_ID }}

      # Step 8: Build, Sign, and Generate Checksums
      - name: üîê Build and Sign All Artifacts
        run: |
          echo "Building and signing all artifacts with checksums..."
          echo "Version: $VERSION"

          # Run Gradle signing diagnostics first
          echo "üîç Running Gradle signing diagnostics..."
          ./gradlew diagnoseSigning --no-daemon

          # Build and sign all artifacts including sources and javadoc
          ./gradlew clean build \
            androidSourcesJar \
            androidJavadocJar \
            publishToMavenLocal \
            --no-daemon \
            --stacktrace \
            --info \
            -Pversion=$VERSION

          echo "‚úÖ All artifacts built and signed successfully"

          # Verify GPG signatures were created during build
          echo "üîç Verifying GPG signatures were created during build..."
          MAVEN_LOCAL_DIR="$HOME/.m2/repository/com/githubim/easysdk-android/$VERSION"

          if [ -d "$MAVEN_LOCAL_DIR" ]; then
            SIGNATURE_FILES=$(find "$MAVEN_LOCAL_DIR" -name "*.asc" | wc -l)
            echo "Found $SIGNATURE_FILES signature files in Maven local repository"

            if [ "$SIGNATURE_FILES" -gt 0 ]; then
              echo "üìã Signature files found:"
              find "$MAVEN_LOCAL_DIR" -name "*.asc" -exec basename {} \;

              # Verify each signature file
              echo "üîç Verifying signature file contents..."
              for asc_file in "$MAVEN_LOCAL_DIR"/*.asc; do
                if [ -f "$asc_file" ]; then
                  filename=$(basename "$asc_file")
                  echo "Checking $filename..."

                  if [ -s "$asc_file" ]; then
                    if head -1 "$asc_file" | grep -q "BEGIN PGP SIGNATURE"; then
                      echo "  ‚úÖ $filename has correct PGP format"

                      # Verify the signature against its corresponding file
                      base_file="${asc_file%.asc}"
                      if [ -f "$base_file" ]; then
                        if gpg --verify "$asc_file" "$base_file" 2>/dev/null; then
                          echo "  ‚úÖ $filename signature verification passed"
                        else
                          echo "  ‚ùå $filename signature verification failed"
                          echo "  üìã Signature content:"
                          head -5 "$asc_file"
                        fi
                      else
                        echo "  ‚ö†Ô∏è Corresponding file for $filename not found"
                      fi
                    else
                      echo "  ‚ùå $filename doesn't have correct PGP format"
                      echo "  üìã File content:"
                      head -3 "$asc_file"
                    fi
                  else
                    echo "  ‚ùå $filename is empty"
                  fi
                fi
              done
            else
              echo "‚ùå No signature files found - signing may have failed"
              echo "üîç Available files in Maven local directory:"
              ls -la "$MAVEN_LOCAL_DIR"
            fi
          else
            echo "‚ùå Maven local directory not found: $MAVEN_LOCAL_DIR"
          fi

          # Generate checksums for all artifacts
          MAVEN_LOCAL_DIR="$HOME/.m2/repository/com/githubim/easysdk-android/$VERSION"
          echo "Generating checksums in: $MAVEN_LOCAL_DIR"

          if [ -d "$MAVEN_LOCAL_DIR" ]; then
            cd "$MAVEN_LOCAL_DIR"

            # Generate MD5 and SHA1 checksums for all artifacts
            for file in *.aar *.pom *.jar; do
              if [ -f "$file" ]; then
                echo "Generating checksums for: $file"

                # Generate MD5 checksum
                md5sum "$file" | cut -d' ' -f1 > "${file}.md5"
                echo "‚úÖ Generated MD5: ${file}.md5"

                # Generate SHA1 checksum
                sha1sum "$file" | cut -d' ' -f1 > "${file}.sha1"
                echo "‚úÖ Generated SHA1: ${file}.sha1"
              fi
            done

            cd - > /dev/null

            echo "üì¶ Final artifacts with checksums and signatures:"
            ls -la "$MAVEN_LOCAL_DIR"

            # Verify we have all required files
            ARTIFACT_COUNT=$(find "$MAVEN_LOCAL_DIR" -name "*.aar" -o -name "*.pom" -o -name "*.jar" | grep -v "\.asc$" | wc -l)
            SIGNATURE_COUNT=$(find "$MAVEN_LOCAL_DIR" -name "*.asc" | wc -l)
            CHECKSUM_COUNT=$(find "$MAVEN_LOCAL_DIR" -name "*.md5" -o -name "*.sha1" | wc -l)

            echo "üìä Artifact summary:"
            echo "   - Artifacts: $ARTIFACT_COUNT"
            echo "   - Signatures: $SIGNATURE_COUNT"
            echo "   - Checksums: $CHECKSUM_COUNT"

            if [ "$SIGNATURE_COUNT" -gt 0 ] && [ "$CHECKSUM_COUNT" -gt 0 ]; then
              echo "‚úÖ All artifacts have signatures and checksums"
              echo "artifacts_ready=true" >> $GITHUB_ENV
            else
              echo "‚ùå Missing signatures or checksums"
              echo "artifacts_ready=false" >> $GITHUB_ENV
            fi
          else
            echo "‚ùå Maven local repository directory not found"
            echo "artifacts_ready=false" >> $GITHUB_ENV
          fi
        env:
          OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
          OSSRH_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}
          SIGNING_KEY_ID: ${{ secrets.SIGNING_KEY_ID }}
          SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}

      # Step 8.5: Validate Portal API Compatible Signatures
      - name: üîç Validate Portal API Signatures
        run: |
          echo "Validating signatures for Portal API compatibility..."
          chmod +x scripts/validate-portal-signatures.sh
          ./scripts/validate-portal-signatures.sh $VERSION
        env:
          SIGNING_KEY_ID: ${{ secrets.SIGNING_KEY_ID }}
          SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}

      # Step 9: Create Portal API Bundle
      - name: üì¶ Create Portal API Bundle
        if: env.artifacts_ready == 'true'
        run: |
          echo "Creating Portal API deployment bundle..."

          # Use Maven local repository as source (contains signed artifacts and checksums)
          MAVEN_LOCAL_DIR="$HOME/.m2/repository/com/githubim/easysdk-android/$VERSION"

          # Run bundle creation script with Maven local repository
          ./scripts/create-portal-bundle.sh $VERSION "$MAVEN_LOCAL_DIR"

          # Verify bundle was created
          if [ -f "central-bundle.zip" ]; then
            BUNDLE_SIZE=$(du -h central-bundle.zip | cut -f1)
            echo "‚úÖ Bundle created successfully: central-bundle.zip ($BUNDLE_SIZE)"

            # Verify bundle contents include signatures and checksums
            echo "üìã Bundle contents:"
            unzip -l central-bundle.zip

            SIGNATURE_COUNT=$(unzip -l central-bundle.zip | grep -c "\.asc$" || true)
            CHECKSUM_COUNT=$(unzip -l central-bundle.zip | grep -c -E "\.(md5|sha1)$" || true)

            # Ensure counts are valid integers
            SIGNATURE_COUNT=${SIGNATURE_COUNT:-0}
            CHECKSUM_COUNT=${CHECKSUM_COUNT:-0}

            echo "üìä Bundle verification:"
            echo "   - Signature files: $SIGNATURE_COUNT"
            echo "   - Checksum files: $CHECKSUM_COUNT"

            if [ "$SIGNATURE_COUNT" -gt 0 ] && [ "$CHECKSUM_COUNT" -gt 0 ]; then
              echo "‚úÖ Bundle contains all required files"
              echo "bundle_created=true" >> $GITHUB_ENV
            else
              echo "‚ö†Ô∏è Bundle missing required files"
              echo "bundle_created=false" >> $GITHUB_ENV
            fi
          else
            echo "‚ùå Failed to create bundle"
            echo "bundle_created=false" >> $GITHUB_ENV
          fi

      # Step 10: Upload to Portal API
      - name: üöÄ Upload to Portal API
        if: env.bundle_created == 'true'
        run: |
          echo "Uploading to Portal API..."

          # Create base64 encoded credentials
          CREDENTIALS=$(echo -n "${{ secrets.OSSRH_USERNAME }}:${{ secrets.OSSRH_PASSWORD }}" | base64)

          # Upload bundle to Portal API
          echo "Uploading bundle to Portal API..."

          # Capture both response and HTTP code
          UPLOAD_RESPONSE=$(curl -X POST \
            -H "Authorization: Bearer $CREDENTIALS" \
            -F "bundle=@central-bundle.zip" \
            -F "name=WuKongIM Android EasySDK v$VERSION" \
            "https://central.sonatype.com/api/v1/publisher/upload?publishingType=USER_MANAGED" \
            --silent --show-error --max-time 300 -w "%{http_code}")

          HTTP_CODE="${UPLOAD_RESPONSE: -3}"
          RESPONSE_BODY="${UPLOAD_RESPONSE%???}"

          echo "Portal API HTTP Code: $HTTP_CODE"
          echo "Portal API Response: $RESPONSE_BODY"

          if [ "$HTTP_CODE" = "201" ] && [ -n "$RESPONSE_BODY" ] && [ "$RESPONSE_BODY" != "null" ]; then
            DEPLOYMENT_ID="$RESPONSE_BODY"
            echo "‚úÖ Portal API upload successful"
            echo "Deployment ID: $DEPLOYMENT_ID"
            echo "portal_deployment_id=$DEPLOYMENT_ID" >> $GITHUB_ENV
            echo "portal_upload_success=true" >> $GITHUB_ENV

            # Monitor deployment status
            echo "Monitoring deployment status..."
            for i in {1..10}; do
              STATUS=$(curl -X POST \
                -H "Authorization: Bearer $CREDENTIALS" \
                "https://central.sonatype.com/api/v1/publisher/status?id=$DEPLOYMENT_ID" \
                --silent | jq -r '.deploymentState' 2>/dev/null || echo "UNKNOWN")

              echo "Status check $i: $STATUS"

              case $STATUS in
                "VALIDATED")
                  echo "‚úÖ Deployment validated and ready for manual release"
                  echo "üîó View at: https://central.sonatype.com/publishing/deployments"
                  break
                  ;;
                "PUBLISHED")
                  echo "üéâ Deployment automatically published to Maven Central"
                  break
                  ;;
                "FAILED")
                  echo "‚ùå Deployment failed validation"
                  curl -X POST \
                    -H "Authorization: Bearer $CREDENTIALS" \
                    "https://central.sonatype.com/api/v1/publisher/status?id=$DEPLOYMENT_ID" \
                    --silent | jq '.errors' 2>/dev/null || echo "No error details available"
                  echo "portal_upload_success=false" >> $GITHUB_ENV
                  exit 1
                  ;;
                "PENDING"|"VALIDATING"|"PUBLISHING")
                  echo "‚è≥ Deployment in progress: $STATUS"
                  if [ $i -eq 10 ]; then
                    echo "‚è∞ Monitoring timeout - check Portal manually"
                    echo "üîó View at: https://central.sonatype.com/publishing/deployments"
                  else
                    sleep 30
                  fi
                  ;;
                *)
                  echo "‚ùì Unknown status: $STATUS"
                  sleep 30
                  ;;
              esac
            done
          else
            echo "‚ùå Portal API upload failed"
            echo "HTTP Code: $HTTP_CODE"
            echo "Response: $RESPONSE_BODY"

            # Check for specific error types
            if echo "$RESPONSE_BODY" | grep -q "Invalid signature"; then
              echo "üîç Signature validation error detected"
              echo "üìã This indicates GPG signing issues in the bundle"
            elif [ "$HTTP_CODE" = "401" ]; then
              echo "üîê Authentication error - check Portal credentials"
            elif [ "$HTTP_CODE" = "400" ]; then
              echo "üì¶ Bundle format error - check bundle contents"
            fi

            echo "portal_upload_success=false" >> $GITHUB_ENV
            exit 1
          fi
        env:
          OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
          OSSRH_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}

      # Step 11: Final Status Report
      - name: üìä Final Publishing Status Report
        if: always()
        run: |
          echo ""
          echo "üéØ PUBLISHING STATUS REPORT"
          echo "================================"
          echo ""
          echo "üì¶ Version: $VERSION"
          echo "üìã Artifacts: $( [ "${{ env.artifacts_ready }}" = "true" ] && echo "‚úÖ Ready" || echo "‚ùå Not Ready" )"
          echo "üì¶ Bundle: $( [ "${{ env.bundle_created }}" = "true" ] && echo "‚úÖ Created" || echo "‚ùå Failed" )"
          echo "üöÄ Upload: $( [ "${{ env.portal_upload_success }}" = "true" ] && echo "‚úÖ Successful" || echo "‚ùå Failed" )"

          if [ -n "${{ env.portal_deployment_id }}" ]; then
            echo "üÜî Deployment ID: ${{ env.portal_deployment_id }}"
          fi

          echo ""
          echo "üìã NEXT STEPS:"

          if [ "${{ env.portal_upload_success }}" = "true" ]; then
            echo "‚úÖ Portal API Upload Successful:"
            echo "   1. üîó Visit: https://central.sonatype.com/publishing/deployments"
            echo "   2. üîç Find deployment: WuKongIM Android EasySDK v$VERSION"
            echo "   3. ‚úÖ Review validation results"
            echo "   4. üöÄ Manually release to Maven Central (if validated)"
            echo "   5. üìä Monitor release progress"
          else
            echo "‚ùå Portal API Upload Failed:"
            echo "   1. üîç Review workflow logs for errors"
            echo "   2. üîê Verify authentication credentials"
            echo "   3. üì¶ Check bundle contents and signatures"
            echo "   4. üîß Fix issues and retry"
          fi

          echo ""
          echo "üîó USEFUL LINKS:"
          echo "   ‚Ä¢ Central Publisher Portal: https://central.sonatype.com/publishing/deployments"
          echo "   ‚Ä¢ Maven Central Search: https://search.maven.org/artifact/com.githubim/easysdk-android"
          echo "   ‚Ä¢ Documentation: https://central.sonatype.org/publish/"
          echo "   ‚Ä¢ Support: central-support@sonatype.com"

          echo ""
          echo "üéâ Publishing workflow completed!"

      # Step 12: Clean up sensitive files
      - name: üßπ Clean Up Sensitive Files
        if: always()
        run: |
          echo "Cleaning up sensitive files..."
          rm -f $HOME/private.key
          rm -f central-bundle.zip
          rm -f central-bundle.zip.metadata
          # Clean up GPG agent
          gpgconf --kill gpg-agent || true
          echo "Cleanup completed"
